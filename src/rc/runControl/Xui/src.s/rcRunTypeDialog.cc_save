//-----------------------------------------------------------------------------
// Copyright (c) 1994,1995 Southeastern Universities Research Association,
//                         Continuous Electron Beam Accelerator Facility
//
// This software was developed under a United States Government license
// described in the NOTICE file included as part of this distribution.
//
// CEBAF Data Acquisition Group, 12000 Jefferson Ave., Newport News, VA 23606
//       coda@cebaf.gov  Tel: (804) 249-7030     Fax: (804) 249-5800
//-----------------------------------------------------------------------------
//
// Description:
//      Implementation of run type dialog
//
// Author:  
//      Jie Chen
//      CEBAF Data Acquisition Group
//
// Revision History:
//   $Log: rcRunTypeDialog.cc,v $
//   Revision 1.6  1998/06/18 12:20:42  heyes
//   new GUI ready I think
//
//   Revision 1.5  1998/04/08 18:31:33  heyes
//   new look and feel GUI
//
//   Revision 1.4  1997/10/15 16:08:32  heyes
//   embed dbedit, ddmon and codaedit
//
//   Revision 1.3  1997/08/01 18:38:17  heyes
//   nobody will believe this!
//
//   Revision 1.2  1997/06/16 12:26:50  heyes
//   add dbedit and so on
//
//   Revision 1.1.1.1  1996/10/11 13:39:26  chen
//   run control source
//
//

#include <stdio.h>

#include <Xm/Form.h>
#include <Xm/PushBG.h>

#include <Xm/FileSB.h>
#include <Xm/DialogS.h>

#include <rcDbaseHandler.h>
#include <rcRunTypeOption.h>
#include <XcodaErrorDialog.h>
#ifdef USE_CREG
#include <codaRegistry.h>
#endif
#include "rcRunTypeDialog.h"
#include "rcXpmComdButton.h"


#include <XcodaFileSelDialog.h>


/*
void
XcodaFileSelDialog::execute()
{
  printf("my execute\n");
}
*/


/*
** Destroy the shell parent of the Message box, and thus the box itself
*/
void
/*rcRunTypeDialog::*/destroy_dialog (Widget dialog, XtPointer client_data, XtPointer call_data)
{
    XtDestroyWidget (XtParent (dialog));
    /* The shell parent of the Message box */
}



/*sergey*/
/* routine to determine if a file is accessible, a directory,
** or writable. Return -1 on all errors or if the file is not 
** writable. Return 0 if it's a directory or 1 if it's a plain
** writable file. 
*/
int
/*rcRunTypeDialog::*/is_writable (char *file)
{
  struct stat s_buf;
  /* if file can't be accessed (via stat()) return. */
  if (stat (file, &s_buf) == -1)
    return -1;
  else if ((s_buf.st_mode & S_IFMT) == S_IFDIR)
    return 0; /* a directory */
  else if (!(s_buf.st_mode & S_IFREG) || access (file, W_OK) == -1)
    /* not a normal file or it is not writable */
    return -1;
  /* legitimate file */
  return 1;
}

/* a new file was selected -- check to see if it's readable and not
** a directory. If it's not readable, report an error. If it's a
** directory, scan it just as though the user had typed it in the mask
** Text field and selected "Search".
*/
void
/*rcRunTypeDialog::*/new_file_cb (Widget widget, XtPointer client_data, XtPointer call_data)
{
  char *file;

  XmFileSelectionBoxCallbackStruct *cbs = (XmFileSelectionBoxCallbackStruct *) call_data;

  /* get the string typed in the text field in char * format */
  if (!(file = (char *) XmStringUnparse (cbs->value,
                                         XmFONTLIST_DEFAULT_TAG,
                                         XmCHARSET_TEXT,
                                         XmCHARSET_TEXT,
                                         NULL, 0, XmOUTPUT_ALL)))
      return;
  if (*file != '/')
  {
    /* if it's not a directory, determine the full pathname 
    ** of the selection by concatenating it to the "dir" part
    */
    char *dir, *newfile; 
    if (dir = (char *)XmStringUnparse (cbs->dir, /*sergey: add casting '(char *)' */
                                   XmFONTLIST_DEFAULT_TAG,
                                   XmCHARSET_TEXT,
                                   XmCHARSET_TEXT,
                                   NULL, 0, XmOUTPUT_ALL))
    {
      newfile = XtMalloc (strlen (dir) + 1 + strlen (file) + 1);
      sprintf (newfile, "%s/%s", dir, file);
      XtFree (file);
      XtFree (dir);
      file = newfile;
    }
  }
  switch (is_writable (file))
  {
    case 1:
      {
        printf("Selected file >%s< will go to the database\n",file);


		printf("1\n");
        rcDbaseHandler* handler = rcDbaseHandler::dbaseHandler ();

        handler->connect("clondb1");
        handler->database("daq_clasdev");

		printf("2\n");
        handler->updateConfigFileName(file);
		printf("3\n");

        handler->close();


		/*
  char *dbasename = 0;
  dbasename = XmComboBoxGetString (exptid_);
  //if (!dbasename || !*dbasename) {
  //  XBell (XtDisplay (_w), 50);
  //  return CODA_ERROR;
  //}
  */

        break;
	  }
    case 0:
      {
        /* a directory was selected, scan it */
        XmString str = XmStringCreateLocalized (file);
        XmFileSelectionDoSearch (widget, str);
        XmStringFree (str);
        break;
      }
    case -1:
      /* a system error on this file */
      perror (file);
  }
  XtFree (file);
}

/* do_search() -- scan a directory and report only those files that
** are writable. Here, we let the shell expand the (possible)
** wildcards and return a directory listing by using popen().
** A *real* application should -not- do this; it should use the
** system's directory routines: opendir(), readdir() and closedir(). 
*/
void
/*rcRunTypeDialog::*/do_search (Widget widget, /* file selection box widget */
                            XtPointer search_data, XtPointer call_data)
{
    char          *mask, buf[BUFSIZ], *p;
    XmString       names[256]; /* maximum of 256 files in dir */
    int            i = 0;
    FILE          *pp;

    XmFileSelectionBoxCallbackStruct *cbs = (XmFileSelectionBoxCallbackStruct 
                                             *) search_data;
    if (!(mask = (char *) XmStringUnparse (cbs->mask,
                                           XmFONTLIST_DEFAULT_TAG,
                                           XmCHARSET_TEXT,
                                           XmCHARSET_TEXT,
                                           NULL, 0, XmOUTPUT_ALL)))
        return; /* can't do anything */
    sprintf (buf, "/bin/ls %s", mask);
    XtFree (mask);
    /* let the shell read the directory and expand the filenames */
    if (!(pp = popen (buf,"r")))
        return;
    /* read output from popen() -- this will be the list of files */
    while (fgets (buf, sizeof buf, pp)) {
        if (p = index (buf, '\n'))
            *p = 0;
        /* only list files that are writable and not directories */
        if (is_writable (buf) == 1 && 
            (names[i] = XmStringCreateLocalized (buf))) i++; 
    }
    pclose (pp); 
    if (i) {
        XtVaSetValues (widget,
                       XmNfileListItems, names,
                       XmNfileListItemCount, i,
                       XmNdirSpec, names[0],
                       XmNlistUpdated, True,
                       NULL);        
        while (i > 0)
            XmStringFree (names[--i]);
    } else
        XtVaSetValues (widget,
                       XmNfileListItems, NULL, 
                       XmNfileListItemCount, 0,
                       XmNlistUpdated, True,
                       NULL);
}








rcRunTypeDialog::rcRunTypeDialog (Widget parent,
				  char* name,
				  char* title,
				  rcClientHandler& handler)
:XcodaFormDialog (parent, name, title), netHandler_ (handler),
 option_ (0), errDialog_ (0), fileDialog_ (0),
 ok_ (0), config_ (0)
{
#ifdef _TRACE_OBJECTS
  printf ("                   Create rcRunTypeDialog Class Object\n");
#endif
  // empty
}

rcRunTypeDialog::~rcRunTypeDialog (void)
{
#ifdef _TRACE_OBJECTS
  printf ("                   Delete rcRunTypeDialog Class Object\n");
#endif
  // empty
  // option_ and dialog_ will be destroyed by Xt destroy mechanism
}

void
rcRunTypeDialog::createFormChildren (void)
{
  Arg arg[20];
  int ac = 0;

  ac = 0;  

  XtSetValues (_w, arg, ac);
  // create option menu first
  option_ = new rcRunTypeOption (_w, "runtype","RunType:",netHandler_, this);
  option_->init ();
  
  ac = 0;  

  // create action form
  XtSetArg (arg[ac], XmNbottomAttachment, XmATTACH_FORM); ac++;
  XtSetArg (arg[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
  XtSetArg (arg[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
  Widget actionForm = XtCreateManagedWidget ("runTypeActionForm",
				      xmFormWidgetClass, _w, arg, ac);

  XtManageChild (actionForm);

  ac = 0;

  // create push buttons
  rcXpmComdButton *ok     = new rcXpmComdButton(actionForm,"Ok",    NULL,"select run type",NULL,netHandler_);
  rcXpmComdButton *config = new rcXpmComdButton(actionForm,"Config",NULL,"select run config",NULL,netHandler_);


  ok->init();
  config->init();

  
  ok_     = ok->baseWidget();
  config_ = config->baseWidget();


  ac = 0;
  XtSetArg (arg[ac], XmNtopAttachment, XmATTACH_FORM); ac++;
  XtSetArg (arg[ac], XmNbottomAttachment, XmATTACH_FORM); ac++;
  XtSetArg (arg[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
  XtSetValues (config_, arg, ac);



  /*sergey: 'Ok' displayed already, do not need following ???
  ac = 0;
  XtSetArg (arg[ac], XmNtopAttachment, XmATTACH_FORM); ac++;
  XtSetArg (arg[ac], XmNbottomAttachment, XmATTACH_FORM); ac++;
  XtSetArg (arg[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
  XtSetArg (arg[ac], XmNrightAttachment, XmATTACH_WIDGET); ac++;
  XtSetArg (arg[ac], XmNrightWidget, ok_); ac++;
  XtSetValues (ok_, arg, ac);
  */



  ac = 0;


  // set resource for option menu
  XtSetArg (arg[ac], XmNtopAttachment, XmATTACH_FORM); ac++;
  XtSetArg (arg[ac], XmNtopOffset, 10); ac++;
  XtSetArg (arg[ac], XmNbottomAttachment, XmATTACH_WIDGET); ac++;
  XtSetArg (arg[ac], XmNbottomWidget, actionForm); ac++;
  XtSetArg (arg[ac], XmNbottomOffset, 10); ac++;
  XtSetArg (arg[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
  XtSetArg (arg[ac], XmNleftOffset, 10); ac++;
  XtSetValues (option_->baseWidget(), arg, ac);
  ac = 0;



  // add callbacks
  XtAddCallback (ok_, XmNactivateCallback,
		 (XtCallbackProc)&(rcRunTypeDialog::okCallback),
		 (XtPointer)this);

  XtAddCallback (config_, XmNactivateCallback,
		 (XtCallbackProc)&(rcRunTypeDialog::configCallback),
		 (XtPointer)this);

  // manage all widgets
  option_->manage ();

  // set up default button
  defaultButton (ok_);
}

void
rcRunTypeDialog::startMonitoringRunTypes (void)
{
  option_->startMonitoringRunTypes (); /* sergey: displays 'runTypes' database table here */
}

void
rcRunTypeDialog::endMonitoringRunTypes (void)
{
  option_->endMonitoringRunTypes ();
}

void
rcRunTypeDialog::configure (void)
{
  if (option_->currentRunType () != 0) {
    rcClient& client = netHandler_.clientHandler ();
    daqData data ("RCS", "command", option_->currentRunType ());
    if (client.sendCmdCallback (DACONFIGURE, data,
		 (rcCallback)&(rcRunTypeDialog::configureCallback),
		 (void *)this) != CODA_SUCCESS)
      reportErrorMsg ("Cannot communication with the RunControl Server\n");
  }
}

void
rcRunTypeDialog::popup (void)
{
  option_->setAllEntries ();

  XcodaFormDialog::popup ();
}

void
rcRunTypeDialog::okCallback (Widget, XtPointer data, XmAnyCallbackStruct *)
{
  rcRunTypeDialog* dialog = (rcRunTypeDialog *)data;
  
  /* get file name selected in 'Config' button */
  printf("FILE >%s<\n",dialog->fileDialog_->selectedFileName());

  dialog->popdown ();
  dialog->configure ();

}

void
rcRunTypeDialog::configCallback (Widget parent, XtPointer data, XmAnyCallbackStruct *)
{
  rcRunTypeDialog* dialog = (rcRunTypeDialog *)data;
  //dialog->popdown ();




  /*sergey: file chooser 

  Arg              args[5];
  int              n = 0;
  XtSetLanguageProc (NULL, NULL, NULL);
  printf("\n\n>>>>>>>>>>>>>>>>>>>>> file chooser\n\n\n");
  XtSetArg (args[n], XmNfileSearchProc, do_search); n++;
  Widget filedialog;
  filedialog = XmCreateFileSelectionDialog (parent, "Files", args, n);
  XtSetSensitive (XtNameToWidget (filedialog, "Help"), False);
  XtAddCallback (filedialog, XmNokCallback, new_file_cb, NULL); // if user presses OK button, call new_file_cb()
  XtAddCallback (filedialog, XmNcancelCallback, destroy_dialog, NULL); // if user presses Cancel button, exit program
  XtManageChild (filedialog);
  */






  /*
  char filename[512];
  dialog->selectConfigFile(filename);
  */
  if (!(dialog->fileDialog_))
  {
    printf("rcRunTypeDialog::selectConfigFile() created\n");
    dialog->fileDialog_ = new XcodaFileSelDialog(parent,"run config file","aaaaa");
    dialog->fileDialog_->init();
  }
  dialog->fileDialog_->popup();

}


/*
void
rcRunTypeDialog::selectConfigFile (char *filename)
{
  if (!fileDialog_)
  {
    printf("rcRunTypeDialog::selectConfigFile() created\n");
    fileDialog_ = new XcodaFileSelDialog(_w,"run config file","aaaaa");
    fileDialog_->init();
  }
  fileDialog_->popup();
  
  printf("Config file >%s< selected !!!\n",fileDialog_->selectedFileName());
}
*/



void
rcRunTypeDialog::reportErrorMsg (char* error)
{
  if (!errDialog_) {
    errDialog_ = new XcodaErrorDialog (_w,"runTypeError", "Configuration Error");
    errDialog_->init ();
  }
  if (errDialog_->isMapped ())
    errDialog_->popdown ();
  errDialog_->setMessage (error);
  errDialog_->popup ();
}


void
rcRunTypeDialog::configureCallback (int status, void* arg, daqNetData* data)
{
  rcRunTypeDialog* obj = (rcRunTypeDialog *)arg;

  if (status != CODA_SUCCESS)
    obj->reportErrorMsg ("Configuring a run failed !!!");
}



