
/* vscm.c - version 1/3/2013 (PRB) */

 

/*
tcpClient svt2 'VSCMInit'
tcpClient svt2 'FSSR_Init()'
tcpClient svt2 'VSCM_FSSRStatus(0)'
*/

/* supported DMA: 2eSST 200MBytes/sec,  BLT32 */

#if defined(VXWORKS) || defined(Linux_vme)

#ifdef VXWORKS
#include <vxWorks.h>
#include <taskLib.h>
#include <ioLib.h>

#include <sockLib.h>
#include <inetLib.h>
#include <hostLib.h>

#else
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h> 
#include <math.h>

#include "vscm.h"

#ifdef VXWORKS
#define SYNC()		{ __asm__ volatile("eieio"); __asm__ volatile("sync"); }
#else
#define SYNC()
#endif

#define LSWAP(x)        ((((x) & 0x000000ff) << 24) | \
                         (((x) & 0x0000ff00) <<  8) | \
                         (((x) & 0x00ff0000) >>  8) | \
                         (((x) & 0xff000000) >> 24))

#define VSCM_BASE_ADDR		0xBE0000

#define VSCM_BASE_ADDR_A32	0x11000000
/*int vscmA32Offset = 0x08000000;*/                      /* Difference in CPU A32 Base - VME A32 Base */

/* Need to update this to ensure FSSR bco clock number is deskewed to VSCM bco clock number*/
#define FSSR_SCR_BCONUM_START	240

#define FSSR_DEBUG_PRINT		0

volatile VSCM_regs *pVSCM_BASE;
volatile unsigned int *pVSCMFifo;

#define STRLEN 1024


/*******************/
/*read config file */

/*
VSCM_ConfigDownload("/usr/local/clas/clas12/parms/vscm/VSCMConfig.txt");
 */

#define VAL_DECODER \
      for(ii=0; ii<nval; ii++) \
	  { \
        if(!strncmp(charval[ii],"0x",2)) sscanf((char *)&charval[ii][2],"%x",&val[ii]); \
        else                             sscanf(charval[ii],"%u",&val[ii]); \
		/*if(!strncmp(charval[ii],"0x",2)) val[ii] = strtol((char *)&charval[ii][2], NULL, 16); \
		else                             val[ii] = strtol((char *)&charval[ii][0], NULL, 10); \
		*/ \
       /* printf("   [%2d] charval >%s<, val=%d (0x%08x)\n",ii,charval[ii],val[ii],val[ii]); */ \
	  } \
      nval = 0

int
VSCM_ConfigDownload(char *fname)
{
  FILE *fd;
  char *ch, str[STRLEN], keyword[STRLEN], charval[10][STRLEN];
  unsigned int val[10];
  int ii, nval;

  if( (fd = fopen(fname,"r")) == NULL)
  {
    printf("VSCM_ConfigDownload: Can't open config file >%s<\n",fname);
    return(-1);
  }

  nval = 0;
  while((ch = fgets(str, STRLEN, fd)) != NULL)
  {
	/*printf(">%s< %d\n",str,ch);*/
    if( ch[0] == '#' || ch[0] == ' ' || ch[0] == '\t' || ch[0] == '\n' || ch[0] == '\r' )
    {
      ;
    }
    else
    {
      sscanf(str,"%s", keyword);
     /* printf("keyword >%s<\n",keyword);  */

      if(     !strcmp(keyword,"FSSR_ADDR_REG_DISC_THR"))
	  { /*0        0        20*/
        sscanf(str,"%s %s %s %s", keyword, charval[0], charval[1], charval[2]);
        nval = 3;        
        VAL_DECODER;
        FSSR_SetThreshold((int)val[0],val[1],val[2]);
	  }
      else if(!strcmp(keyword,"FSSR_ADDR_REG_KILL"))
	  { /*0        0x00000000        0x00000000        0x00000000        0x00000000*/
        sscanf(str,"%s %s %s %s %s %s", keyword, charval[0], charval[1], charval[2], charval[3], charval[4]);
        nval = 5;        
        VAL_DECODER;
        FSSR_KillSelect(val[0],(unsigned int *)&val[1]);
	  }
      else if(!strcmp(keyword,"FSSR_ADDR_REG_INJECT"))
	  { /*0        0x00000000        0x00000000        0x00000000        0x00000000*/
        sscanf(str,"%s %s %s %s %s %s", keyword, charval[0], charval[1], charval[2], charval[3], charval[4]);
        nval = 5;        
        VAL_DECODER;
        FSSR_InjectSelect(val[0],(unsigned int *)&val[1]);
	  }
      else if(!strcmp(keyword,"FSSR_ADDR_REG_DCR"))
	  { /*0        0x1F*/
        sscanf(str,"%s %s %s", keyword, charval[0], charval[1]);
        nval = 2;        
        VAL_DECODER;
        FSSR_SetControl(val[0],val[1]);
	  }
      else if(!strcmp(keyword,"VSCM_BCO_FREQ"))
	  { /*32*/
        sscanf(str,"%s %s", keyword, charval[0]);
        nval = 1;        
        VAL_DECODER;
        VSCMSetBCOClockFreq(val[0]);
	  }
      else if(!strcmp(keyword,"VSCM_TRIG_WINDOW"))
	  { /*256        512        32*/
        sscanf(str,"%s %s %s %s", keyword, charval[0], charval[1], charval[2]);
        nval = 3;
        VAL_DECODER;
        VSCM_SetupTriggerWindow(val[0],val[1],val[2]);
	  }
      else
	  {
        printf("VSCM_ConfigDownload ERROR: unknown keyword >%s< (%d 0x%02x)\n",keyword,ch[0],ch[0]);
        return(-3);
	  }
	}
  }

  fclose(fd);

  return(0);
}


/*******************/
/*******************/

void
VSCM_SetHitMask(int mask)
{
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->FssrHitReg, mask);
}


unsigned int
VSCM_ReadReg(unsigned int addr)
{
	volatile unsigned int *vmeAddr = (volatile unsigned int *)addr;
	/*
	volatile unsigned int result = *vmeAddr;
	SYNC()
	return result;
	*/
	return(vmeRead32(vmeAddr));
}

void
VSCM_WriteReg(unsigned int addr, unsigned int val)
{
	volatile unsigned int *vmeAddr = (volatile unsigned int *)addr;
	/*
	*vmeAddr = val;
	SYNC()
	*/

  vmeWrite32(vmeAddr,val);
}

void
FSSR_Init()
{
	int i, j, v;
	unsigned int mask[4], mask2[4];
	printf("\nInitializing FSSR2 Chips\n");
	
	/*	mask[0] = 0x7F7F7F7F;*/
	/*	mask[1] = 0x7F7F7F7F;*/
	/*	mask[2] = 0x7F7F7F7F;*/
	/*	mask[3] = 0x7F7F7F7F;*/

	/*0-enable, 1-disable*/
    for(i=0; i<4; i++)
    {
       mask[i]=0;
       mask2[i]=0;
	}
	/*
	mask[0] = 0xFFFFFFFE;
	mask[1] = 0xFFFFFFFF;
	mask[2] = 0xFFFFFFFF;
	mask[3] = 0x7FFFFFFF;
	mask2[0] = 0x1;
	mask2[1] = 0x0;
	mask2[2] = 0x0;
	mask2[3] = 0x80000000;
	*/	

	/*01001 01010 01011 01100*/
	FSSR_SetChipId(0x9, 0xA, 0xB, 0xC); /*set chip IDs for 4 chips*/
	
    /*preparation for sync (loading regs) */
	FSSR_MasterReset();
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->FssrSerClk, 0);

    /* loop over 8 chips*/
	for(i = 0; i < 8; i++)
	{
		FSSR_SetControl(i, FSSR_DCR_MOD256 | 0xf);
		FSSR_SetActiveLines(i, FSSR_ALINES_6);
		FSSR_RejectHits(i, 1);
		for(j=0; j<8; j++) FSSR_SetThreshold(i, j, 50); /*set common threshold for chip*/
		FSSR_KillSelect(i, mask);
		FSSR_InjectSelect(i, mask2);
		FSSR_SetInternalPulserAmplitude(i, 100);
	}

	
    VSCM_ConfigDownload("/usr/local/clas/clas12/parms/vscm/VSCMConfig.txt");

	/* Issue S/W sync: comment out if hardware sync is expected*/
	VSCM_SWSync(); 

	for(i = 0; i < 8; i++)
	{
		FSSR_RejectHits(i, 0);
		FSSR_SCR(i);
		FSSR_SendData(i, 1);
	}

}


void
FSSR_InternalPulserEnable(int id)
{
  FSSR_Transfer(id, 2, FSSR_CMD_DEFAULT, 1, NULL);
}

void
FSSR_SetInternalPulserAmplitude(int id, unsigned int mask)
{
  FSSR_Transfer(id, 1, FSSR_CMD_WRITE, 8, &mask);
}

unsigned int
FSSR_ReadInternalPulserAmplitude(int id)
{
	unsigned int rsp;
	
	FSSR_Transfer(id, 1, FSSR_CMD_READ, 9, &rsp);
	return rsp & 0xFF;
}





void
FSSR_SetControl(int id, unsigned int mask)
{
  FSSR_Transfer(id, FSSR_ADDR_REG_DCR, FSSR_CMD_WRITE, 8, &mask);
}

unsigned int
FSSR_ReadControl(int id)
{
	unsigned int rsp;
	
	FSSR_Transfer(id, FSSR_ADDR_REG_DCR, FSSR_CMD_READ, 9, &rsp);
#if FSSR_DEBUG_PRINT
	printf("Control = 0x%02X\n", rsp & 0xFF);
#endif
	
	return rsp & 0xFF;
}



int
FSSR_ParseControl(int id, char *s)
{
	unsigned int val;
	char str[15];

	if (strlen(s) < strlen(str))
		return (-1);

	val = FSSR_ReadControl(id);

	switch (val & 3) {
		case 0:
			strcpy(str, "65, ");
			break;
		case 1:
			strcpy(str, "85, ");
			break;
		case 2:
			strcpy(str, "100, ");
			break;
		case 3:
			strcpy(str, "125, ");
			break;
	}

	switch ((val >> 2) & 1) {
		case 0:
			strcat(str, "High, ");
			break;
		case 1:
			strcat(str, "Low, ");
			break;
	}

	switch ((val >> 3) & 1) {
		case 0:
			strcat(str, "On");
			break;
		case 1:
			strcat(str, "Off");
			break;
	}

	strcpy(s, str);
	return (0);
}





/* threshold for 'idx' parts of the chip*/
void
FSSR_SetThreshold(int id, unsigned int idx, unsigned int thr)
{
  unsigned int reg = thr;

  FSSR_Transfer(id, FSSR_ADDR_REG_DISC_THR0+idx, FSSR_CMD_WRITE, 8, &reg);
}

unsigned int
FSSR_ReadThreshold(int id, unsigned int idx)
{
	unsigned int rsp;
	
	FSSR_Transfer(id, FSSR_ADDR_REG_DISC_THR0+idx, FSSR_CMD_READ, 9, &rsp);
#if FSSR_DEBUG_PRINT
	printf("Threshold %d = %d\n", idx, rsp & 0xFF);
#endif

	return rsp & 0xFF;
}


void
FSSR_SetVtn(int id, unsigned int thr)
{
	unsigned int reg = thr;

	FSSR_Transfer(id, FSSR_ADDR_REG_DISC_VTN, FSSR_CMD_WRITE, 8, &reg);
}

unsigned int
FSSR_ReadVtn(int id)
{
	unsigned int rsp;

	FSSR_Transfer(id, FSSR_ADDR_REG_DISC_VTN, FSSR_CMD_READ, 9, &rsp);
#if FSSR_DEBUG_PRINT
	printf("Threshold 7 = %d\n", rsp & 0xFF);
#endif

	return rsp & 0xFF;
}

int
FSSR_WaitReady(void)
{
	int i;
	for(i = 0; i < 10; i++) {
		if(VSCM_ReadReg((unsigned int)&pVSCM_BASE->FssrSerCfg) & (1<<14))
			return 1;
		taskDelay(1);
	}
	/*printf("Error: FSSR_WaitReady() interface timeout.\n");*/
	return 0;
}



/*slow control: FSSR chip registers setup*/
void
FSSR_Transfer(unsigned char Sel, unsigned char Addr, unsigned char Cmd, unsigned char nBits, unsigned int *pData)
{
	unsigned int SerCfgReg = 0;
	unsigned int rsp[4];
	int i;
	
	SerCfgReg |= (Sel & 0xF)<<24;
	SerCfgReg |= (Addr & 0x1F)<<0;
	SerCfgReg |= (Cmd & 0x7)<<8;
	SerCfgReg |= (nBits & 0xFF)<<16;
	SerCfgReg |= (1<<15);

	if(pData && nBits > 0) VSCM_WriteReg((unsigned int)&pVSCM_BASE->FssrSerData[0], pData[0]);
	if(pData && nBits > 32) VSCM_WriteReg((unsigned int)&pVSCM_BASE->FssrSerData[1], pData[1]);
	if(pData && nBits > 64) VSCM_WriteReg((unsigned int)&pVSCM_BASE->FssrSerData[2], pData[2]);
	if(pData && nBits > 96) VSCM_WriteReg((unsigned int)&pVSCM_BASE->FssrSerData[3], pData[3]);
	
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->FssrSerCfg, SerCfgReg);
	
	taskDelay(1);
	
	SerCfgReg = VSCM_ReadReg((unsigned int)&pVSCM_BASE->FssrSerCfg);
	if(!(SerCfgReg & (1<<14)))
		printf("Error: FSSRTransfer() interface timeout.\n");

	if(pData && (Cmd == FSSR_CMD_READ))
	{
		rsp[0] = VSCM_ReadReg((unsigned int)&pVSCM_BASE->FssrSerData[0]);
		rsp[1] = VSCM_ReadReg((unsigned int)&pVSCM_BASE->FssrSerData[1]);
		rsp[2] = VSCM_ReadReg((unsigned int)&pVSCM_BASE->FssrSerData[2]);
		rsp[3] = VSCM_ReadReg((unsigned int)&pVSCM_BASE->FssrSerData[3]);
		for(i = 0; i < nBits; i++)
		{
			if(i >= 96)
			{
				if(i == 96) pData[3] = 0;
				if(rsp[0] & (1<<(127-i)))
					pData[3] |= 1<<(i-96);
			}
			else if(i >= 64)
			{
				if(i == 64) pData[2] = 0;
				if(rsp[1] & (1<<(95-i)))
					pData[2] |= 1<<(i-64);
			}
			else if(i >= 32)
			{
				if(i == 32) pData[1] = 0;
				if(rsp[2] & (1<<(63-i)))
					pData[1] |= 1<<(i-32);
			}
			else
			{
				if(i == 0) pData[0] = 0;
				if(rsp[3] & (1<<(31-i)))
					pData[0] |= 1<<i;
			}
		}
	}
	
#if FSSR_DEBUG_PRINT
	if(Cmd == FSSR_CMD_READ)
	{
		printf("Data response: 0x%08X 0x%08X 0x%08X 0x%08X\n", VSCM_ReadReg((unsigned int)&pVSCM_BASE->FssrSerData[3]),
															   VSCM_ReadReg((unsigned int)&pVSCM_BASE->FssrSerData[2]),
															   VSCM_ReadReg((unsigned int)&pVSCM_BASE->FssrSerData[1]),
															   VSCM_ReadReg((unsigned int)&pVSCM_BASE->FssrSerData[0]));
	}
#endif
}



void
FSSR_RegSet(int id, int reg)
{
	FSSR_Transfer(id, reg, FSSR_CMD_SET, 1, NULL);
}

void
FSSR_RegClear(int id, int reg)
{
	FSSR_Transfer(id, reg, FSSR_CMD_RESET, 1, NULL);
}

void
FSSR_MasterReset()
{
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->FssrSerCfg, 0xF<<28);
	taskDelay(1);
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->FssrSerCfg, 0);
	taskDelay(1);
}


/* Disable all channels on a chip */
void
FSSR_KillMask_DisableAll(int chip)
{
	unsigned int mask[4];
	mask[0] = 0xFFFFFFFF;
	mask[1] = 0xFFFFFFFF;
	mask[2] = 0xFFFFFFFF;
	mask[3] = 0xFFFFFFFF;
	FSSR_KillSelect(chip, mask);
}

/* Enable all channels on a chip */
void
FSSR_KillMask_EnableAll(int chip)
{
	unsigned int mask[4];
	mask[0] = 0;
	mask[1] = 0;
	mask[2] = 0;
	mask[3] = 0;
	FSSR_KillSelect(chip, mask);
}

/* Toggle a single channel on a chip via kill mask
   boolean = 1 = disable the channel
   boolean = 0 = enable the channel
*/
void
FSSR_KillMask_Single(int chip, int chan, int boolean)
{
	unsigned int mask[4], readmask[4];
	unsigned int v, i;

	if (chan >=0 && chan <= 127) {
		chan = 127 - chan;
		FSSR_ReadKillSelect(chip, readmask);

		for (i = 0; i < 4; i++) {
			v = readmask[i];
			/* Reverse Bit Sequence */
			/* http://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel */
			v = ((v >> 1) & 0x55555555) | ((v & 0x55555555) << 1);
			v = ((v >> 2) & 0x33333333) | ((v & 0x33333333) << 2);
			v = ((v >> 4) & 0x0F0F0F0F) | ((v & 0x0F0F0F0F) << 4);
			v = ((v >> 8) & 0x00FF00FF) | ((v & 0x00FF00FF) << 8);
			v = ( v >> 16             ) | ( v               << 16);

			mask[3 - i] = v;
		}

		if (boolean == 1)
			mask[chan >> 5] |= (1 << (chan & 0x1F));
		else if (boolean == 0)
			mask[chan >> 5] &= ~(1 << (chan & 0x1F));

		FSSR_KillSelect(chip, mask);
	}
	else
		fprintf(stderr, "FSSR_KillMask_Single() bad channel #\n");
}

/* Toggle a single channel (disabled) on a chip */
void
FSSR_KillMask_DisableSingle(int chip, int chan)
{
		FSSR_KillMask_Single(chip, chan, 1);
}

/* Toggle a single channel (enable) on a chip */
void
FSSR_KillMask_EnableSingle(int chip, int chan)
{
		FSSR_KillMask_Single(chip, chan, 0);
}

/* Inject all channels on a chip */
void
FSSR_InjectMask_EnableAll(int chip)
{
	unsigned int mask[4];
	mask[0] = 0xffffffff;
	mask[1] = 0xffffffff;
	mask[2] = 0xffffffff;
	mask[3] = 0xffffffff;
	FSSR_InjectSelect(chip, mask);
}

/* disable all channels*/
void
FSSR_DisableAll()
{
  int ii;
	unsigned int mask[4];
	for(ii=0; ii<8; ii++)
	{
  	  mask[0] = 0xFFFFFFFF;
	  mask[1] = 0xFFFFFFFF;
	  mask[2] = 0xFFFFFFFF;
	  mask[3] = 0xFFFFFFFF;
      FSSR_KillSelect(ii, mask);
	}
}

void
FSSR_EnableOnly(int id, unsigned int ch)
{
	unsigned int mask[4] = {0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff};
	unsigned int readmask[4] = {0, 0, 0, 0};
	unsigned int v;
	int i, bad = 0;
	
	if(ch >= 0 && ch <= 127) {
      ch = 127 - ch;
      mask[ch>>5] = mask[ch>>5] ^ (1<<(ch&0x1F));

		FSSR_KillSelect(id, mask);
		FSSR_ReadKillSelect(id, readmask);

		for (i = 0; i < 4; i++) {
			v = readmask[i];
			/* Reverse Bit Sequence */
			/* http://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel */
			v = ((v >> 1) & 0x55555555) | ((v & 0x55555555) << 1);
			v = ((v >> 2) & 0x33333333) | ((v & 0x33333333) << 2);
			v = ((v >> 4) & 0x0F0F0F0F) | ((v & 0x0F0F0F0F) << 4);
			v = ((v >> 8) & 0x00FF00FF) | ((v & 0x00FF00FF) << 8);
			v = ( v >> 16             ) | ( v               << 16);

			if (mask[3 - i] != v)
				bad |= 1;
		}
		if (bad)
			fprintf(stderr, "FSSR_EnableOnly() mask not set correctly\n");
	}
	else
		fprintf(stderr, "FSSR_EnableOnly() bad channel #\n");
}

void
FSSR_InjectOnly(int id, unsigned int ch)
{
	unsigned int mask[4] = {0, 0, 0, 0};
	unsigned int readmask[4] = {0, 0, 0, 0};
	unsigned int v;
	int i, bad = 0;

	if (ch >= 0 && ch <= 127) {	
		ch = 127 - ch;
		mask[ch>>5] = mask[ch>>5] ^ (1<<(ch&0x1F));

		FSSR_InjectSelect(id, mask);
		FSSR_ReadInjectSelect(id, readmask);

		for (i = 0; i < 4; i++) {
			v = readmask[i];
			/* Reverse Bit Sequence */
			/* http://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel */
			v = ((v >> 1) & 0x55555555) | ((v & 0x55555555) << 1);
			v = ((v >> 2) & 0x33333333) | ((v & 0x33333333) << 2);
			v = ((v >> 4) & 0x0F0F0F0F) | ((v & 0x0F0F0F0F) << 4);
			v = ((v >> 8) & 0x00FF00FF) | ((v & 0x00FF00FF) << 8);
			v = ( v >> 16             ) | ( v               << 16);

			if (mask[3 - i] != v)
				bad |= 1;
		}
		if (bad)
			fprintf(stderr, "FSSR_InjectOnly() mask not set correctly\n");
	}
	else
		fprintf(stderr, "FSSR_InjectOnly() bad channel #\n");
}


/* disable channels in according to the mask*/
void
FSSR_KillSelect(int id, unsigned int *mask)
{
	FSSR_Transfer(id, FSSR_ADDR_REG_KILL, FSSR_CMD_WRITE, 128, mask);
}


void
FSSR_ReadKillSelect(int id, unsigned int *mask)
{
  /* need to fix firmware for reads for this to work properly*/
	mask[0] = 0;
	mask[1] = 0;
	mask[2] = 0;
	mask[3] = 0;

	FSSR_Transfer(id, FSSR_ADDR_REG_KILL, FSSR_CMD_READ, 129, mask);
	
#if FSSR_DEBUG_PRINT
	printf("Kill [ch127->0] = 0x%08X 0x%08X 0x%08X 0x%08X\n", mask[3], mask[2], mask[1], mask[0]);
#endif
}

void
FSSR_InjectSelect(int id, unsigned int *mask)
{
	FSSR_Transfer(id, FSSR_ADDR_REG_INJECT, FSSR_CMD_WRITE, 128, mask);
}

void
FSSR_ReadInjectSelect(int id, unsigned int *mask)
{
  /* need to fix firmware for reads for this to work properly*/
	mask[0] = 0;
	mask[1] = 0;
	mask[2] = 0;
	mask[3] = 0;
	FSSR_Transfer(id, FSSR_ADDR_REG_INJECT, FSSR_CMD_READ, 129, mask);

#if FSSR_DEBUG_PRINT
	printf("Inject [ch127->0] = 0x%08X 0x%08X 0x%08X 0x%08X\n", mask[3], mask[2], mask[1], mask[0]);
#endif
}

void
FSSR_InjectDisableAll()
{
  int ii, jj;
  unsigned int mask[4];

  for(ii=0; ii<8; ii++)
  {
    for(jj=0; jj<4; jj++) mask[jj] = 0;
    FSSR_Transfer(ii, FSSR_ADDR_REG_INJECT, FSSR_CMD_WRITE, 128, mask);
  }
}


unsigned int
FSSR_ReadBCONum(int id)
{
	return FSSR_ReadBCONumOffset(id, FSSR_SCR_BCONUM_START);
}

unsigned int
FSSR_ReadBCONumOffset(int id, unsigned char offset)
{
	unsigned int rsp;
	
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->FssrSerClk, 0x100 | (offset+1) & 0xFF);
	FSSR_Transfer(id, FSSR_ADDR_REG_AQBCO, FSSR_CMD_SET, 1, NULL);
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->FssrSerClk, 0);
	FSSR_Transfer(id, FSSR_ADDR_REG_AQBCO, FSSR_CMD_READ, 9, &rsp);

#if FSSR_DEBUG_PRINT
	printf("BCO {sync @ %d] = %u\n", offset, rsp & 0xFF);
#endif
	
	return rsp & 0xFF;
}

unsigned int
FSSR_ReadBCONumNoSync(int id)
{
	unsigned int rsp, i;
	
	FSSR_Transfer(id, FSSR_ADDR_REG_AQBCO, FSSR_CMD_SET, 1, NULL);
	FSSR_Transfer(id, FSSR_ADDR_REG_AQBCO, FSSR_CMD_READ, 9, &rsp);
	
#if FSSR_DEBUG_PRINT
	printf("BCO {no sync] = %u\n", rsp & 0xFF);
#endif

	return rsp & 0xFF;
}










void
FSSR_RejectHits(int id, int reject)
{
	if(reject)
		FSSR_Transfer(id, FSSR_ADDR_REG_REJECTHITS, FSSR_CMD_SET, 1, NULL);
	else
		FSSR_Transfer(id, FSSR_ADDR_REG_REJECTHITS, FSSR_CMD_RESET, 1, NULL);
}


void
FSSR_SendData(int id, int send)
{
	if(send)
		FSSR_Transfer(id, FSSR_ADDR_REG_SENDDATA, FSSR_CMD_SET, 1, NULL);
	else
		FSSR_Transfer(id, FSSR_ADDR_REG_SENDDATA, FSSR_CMD_RESET, 1, NULL);
}

/*activate up to 6 lines to be used for readout, 140MBits/sec per line*/
void
FSSR_SetActiveLines(int id, unsigned int lines)
{
	unsigned int reg = lines & 0x3;
	FSSR_Transfer(id, FSSR_ADDR_REG_ALINES, FSSR_CMD_WRITE, 2, &reg);
}

/* set chip id to be used in other calls */
void
FSSR_SetChipId(unsigned char u1, unsigned char u2, unsigned char u3, unsigned char u4)
{
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->FssrAddrH1, (u4<<24) | (u3<<16) | (u2<<8) | (u1<<0));
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->FssrAddrH2, (u4<<24) | (u3<<16) | (u2<<8) | (u1<<0));
}

/*sync signal, call it in 'Go()', must do it after hardware sync from master TID*/
void
FSSR_SCR(int id)
{
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->FssrSerClk, 0x100 | FSSR_SCR_BCONUM_START);
	FSSR_Transfer(id, FSSR_ADDR_REG_SCR, FSSR_CMD_SET, 1, NULL);
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->FssrSerClk, 0);
}

/*get scalers to the buffer*/
char *
ReadNormalizedScaler(char *buf, char *prefix, unsigned int ref, unsigned int scaler)
{
	double normalized = 125.0e6 * (double)scaler / (double)ref;
	sprintf(buf, "%s = %08u, %.1fHz\n", prefix, scaler, normalized);
	return buf;
}

/*get scalers on screen*/
void
VSCM_FSSRStatus(int id)
{
	unsigned int ref, status;
	unsigned int mask[4];
	char buf[100];
	
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->ScalerLatch, 0xFF & ~(1<<id));

	ref = VSCM_ReadReg((unsigned int)&pVSCM_BASE->Fssr[id].ScalerRef);
	
	switch(id)
	{
		case 0: printf("HFCB 1 U1:\n"); break;
		case 1: printf("HFCB 1 U2:\n"); break;
		case 2: printf("HFCB 1 U3:\n"); break;
		case 3: printf("HFCB 1 U4:\n"); break;
		case 4: printf("HFCB 2 U1:\n"); break;
		case 5: printf("HFCB 2 U2:\n"); break;
		case 6: printf("HFCB 2 U3:\n"); break;
		case 7: printf("HFCB 2 U4:\n"); break;
	}
	printf("----------- Status ------------\n");
	printf("Last Status Word   = 0x%08X\n", VSCM_ReadReg((unsigned int)&pVSCM_BASE->Fssr[id].LastStatusWord));
	printf(ReadNormalizedScaler(buf, "StatusWordCount   ", ref, VSCM_ReadReg((unsigned int)&pVSCM_BASE->Fssr[id].ScalerStatusWord)));
	printf(ReadNormalizedScaler(buf, "EventWordCount    ", ref, VSCM_ReadReg((unsigned int)&pVSCM_BASE->Fssr[id].ScalerEvent)));
	printf(ReadNormalizedScaler(buf, "TotalWordCount    ", ref, VSCM_ReadReg((unsigned int)&pVSCM_BASE->Fssr[id].ScalerWords)));
	printf(ReadNormalizedScaler(buf, "IdleWordCount     ", ref, VSCM_ReadReg((unsigned int)&pVSCM_BASE->Fssr[id].ScalerIdle)));
	printf(ReadNormalizedScaler(buf, "AcqBcoCount       ", ref, VSCM_ReadReg((unsigned int)&pVSCM_BASE->Fssr[id].ScalerAqBco)));
	printf(ReadNormalizedScaler(buf, "MarkErrors        ", ref, VSCM_ReadReg((unsigned int)&pVSCM_BASE->Fssr[id].ScalerMarkErr)));
	printf(ReadNormalizedScaler(buf, "StripEncodeErrors ", ref, VSCM_ReadReg((unsigned int)&pVSCM_BASE->Fssr[id].ScalerEncErr)));
	printf(ReadNormalizedScaler(buf, "ChipIdErrors      ", ref, VSCM_ReadReg((unsigned int)&pVSCM_BASE->Fssr[id].ScalerChipIdErr)));
	printf(ReadNormalizedScaler(buf, "GotHit            ", ref, VSCM_ReadReg((unsigned int)&pVSCM_BASE->Fssr[id].ScalerGotHit)));
	
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->ScalerLatch, 0xFF);

	printf("----------- Config ------------\n");	
	printf("FSSR BCO Clock Period: %dns\n", VSCM_ReadReg((unsigned int)&pVSCM_BASE->FssrClkCfg) * 8);
	printf("FSSR Control: 0x%02X\n", FSSR_ReadControl(id));
	printf("FSSR Thresholds: %d %d %d %d %d %d %d %d\n",
		FSSR_ReadThreshold(id, 0), FSSR_ReadThreshold(id, 1),
		FSSR_ReadThreshold(id, 2), FSSR_ReadThreshold(id, 3),
		FSSR_ReadThreshold(id, 4), FSSR_ReadThreshold(id, 5),
		FSSR_ReadThreshold(id, 6), FSSR_ReadThreshold(id, 7));
		
	FSSR_ReadKillSelect(id, mask);
	printf("FSSR Kill[ch127->0]: 0x%08X 0x%08X 0x%08X 0x%08X\n", mask[3], mask[2], mask[1], mask[0]);
	
	FSSR_ReadInjectSelect(id, mask);
	printf("FSSR Inject[ch127->0]: 0x%08X 0x%08X 0x%08X 0x%08X\n", mask[3], mask[2], mask[1], mask[0]);

	printf("FSSR BCO[@0 @128, @255]: %d %d %d\n",
		FSSR_ReadBCONumOffset(id, FSSR_SCR_BCONUM_START),
		FSSR_ReadBCONumOffset(id, FSSR_SCR_BCONUM_START-128),
		FSSR_ReadBCONumOffset(id, FSSR_SCR_BCONUM_START-1));
	printf("\n");	
}

void
VSCM_FIFOClear() {
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->Reset, 1);
}

/*software sync, use in standalone if the is no master sync*/
void VSCM_SWSync()
{
	unsigned int reg = VSCM_ReadReg((unsigned int)&pVSCM_BASE->Sync);
	
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->Sync, (reg & 0xFFFFFFF0) | IO_MUX_0); 
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->Sync, (reg & 0xFFFFFFF0) | IO_MUX_1); 
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->Sync, reg); 
}


/* windowSize:      trigger accept window width (in 8ns counts)
 windowsLookback: trigger accept window lookback before trigger (in 8ns counts)
 need to fix these parameters...not quite right when window/lookback are fractions of BCO periods
*/
void
VSCM_SetupTriggerWindow(unsigned int windowSize, unsigned int windowLookback, unsigned int bcoFreq)
{
	unsigned int bcoStop_i, bcoStop_r;
	unsigned int bcoStart_i, bcoStart_r;
	
	bcoStart_i = (0x100 - windowLookback / bcoFreq) & 0xFF;
	bcoStart_r = (0x100 - windowLookback % bcoFreq) & 0xFF;

	bcoStop_i = (0x100 - (windowLookback - windowSize - bcoFreq) / bcoFreq) & 0xFF;
	bcoStop_r = (0x100 - (windowLookback - windowSize - bcoFreq) % bcoFreq) & 0xFF;
	
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->TriggerWindow,
	   (bcoStart_r<<0) | (bcoStart_i<<8) |
	   (bcoStop_r<<16) | (bcoStop_i<<24));
	   
	printf("\n VSCM Triggering window init: bcoStart(%u,%u) bcoStop(%u,%u)\n", bcoStart_i, bcoStart_r, bcoStop_i, bcoStop_r);
}

/*debug*/
void
VSCM_TestWriteSRAM(unsigned int addr, unsigned int val)
{
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->SramDbgAdr, addr);
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->SramDbgData, val);
}

/*debug*/
unsigned int
VSCM_TestReadSRAM(unsigned int addr)
{
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->SramDbgAdr, addr);
	return VSCM_ReadReg((unsigned int)&pVSCM_BASE->SramDbgData);
}


/*print fifo*/
void
VSCMPrintFIFO(unsigned int *buf, int n)
{
  int i;
  unsigned int word;
  for(i = 0; i < n; i++)
  {
#ifdef VXWORKS
    unsigned int word = buf[i];
#else
    unsigned int word = LSWAP(buf[i]);
#endif
    printf("0x%08X", word);
			
    if(word & 0x80000000)
    {
      int type = (word>>27)&0xF;
      switch(type)
      {
        case DATA_TYPE_BLKHDR:
          printf(" {BLKHDR} SLOTID: %d", (word>>22)&0x1f);
	  printf(" NEVENTS: %d", (word>>11)&0x7ff);
	  printf(" BLOCK: %d\n", (word>>0)&0x7ff);	
	  break;
        case DATA_TYPE_BLKTLR:
          printf(" {BLKTLR} SLOTID: %d", (word>>22)&0x1f);
	  printf(" NWORDS: %d\n", (word>>0)&0x3fffff);
	  break;
        case DATA_TYPE_EVTHDR:
	  printf(" {EVTHDR} EVENT: %d\n", (word>>0)&0x7ffffff);
	  break;
        case DATA_TYPE_TRGTIME:
	  printf(" {TRGTIME}\n");
	  break;
        case DATA_TYPE_FSSREVT:
	  printf(" {FSSREVT}");
	  printf(" HFCBID: %1u", (word>>20)&0x1);
	  printf(" CHIPID: %1u", (word>>19)&0x7);
	  printf(" CH: %3u", (word>>12)&0x7F);
	  printf(" BCO: %3u", (word>>4)&0xFF);
	  printf(" ADC: %1u\n", (word>>0)&0x7);
	  break;
        case DATA_TYPE_DNV:
	  printf(" {***DNV***}\n");
          return;
	  break;
        case DATA_TYPE_FILLER:
	  printf(" {FILLER}\n");
	  break;
        default:
	  printf(" {***DATATYPE ERROR***}\n");
          return;
	  break;
      }
    }
    else
    {
      printf("\n");
    }
  }
  return;
}


/*read data from fifo*/
int
VSCMReadoutFIFO(unsigned int *buf, int nwmax)
{
  volatile unsigned int *pA32Buf;
  int n, retVal;

  retVal = usrVme2MemDmaStart((unsigned int *)VSCM_BASE_ADDR_A32, (unsigned int *)buf, (nwmax<<2));
  if(retVal |= 0) 
  {
    logMsg(" ERROR in DMA transfer Initialization 0x%x\n",retVal,2,3,4,5,6);
    return(0);
  }

  retVal = usrVme2MemDmaDone();
  if(retVal > 0)
  {
    n = retVal>>2; /* Number of longwords transfered */
    /*logMsg("Number of Long words transfered in VSCMReadoutFIFO (n) =%d\n",n,2,3,4,5,6);*/
  }
  else if (retVal == 0) 
  {
    logMsg("usrVme2MemDmaDone: WARN: DMA transfer returned zero word count 0x%x\n",retVal,2,3,4,5,6);
    return(0);
  }
  else 
  {  /* Error in DMA */
    logMsg("ERROR: vmeDmaDone returned an Error %d\n",retVal,2,3,4,5,6);
    return(0);
  }
  return(n);
}



/*print statistics*/
void
VSCMStat()
{
	printf("\nVSCM in VME slot: %d\n", VSCM_ReadReg((unsigned int)&pVSCM_BASE->Geo));
	printf("FIFO Word Count: %u\n", VSCM_ReadReg((unsigned int)&pVSCM_BASE->FifoWordCnt));
	printf("FIFO Event Count: %u\n", VSCM_ReadReg((unsigned int)&pVSCM_BASE->FifoEventCnt));
}

/*debug*/
void
VSCMPulseFPOuput(int idx)
{
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->FpOutput[idx], IO_MUX_1);
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->FpOutput[idx], IO_MUX_0);
}


/*set bco frequency*/
void
VSCMSetBCOClockFreq(unsigned int freq)
{
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->FssrClkCfg, freq);

	/* Issue S/W sync: comment out if hardware sync is expected
	VSCM_SWSync(); 
    */
}


/*internal pulser for debugging*/
void
VSCM_SetupPulser(unsigned int freq, unsigned int duty, unsigned int pulses)
{
	unsigned int periodCycles;
	unsigned int dutyCycles;
	
	if(!freq)
	{
		periodCycles = VSCM_SYS_CLK;
		dutyCycles = VSCM_SYS_CLK+1;
	}
	else
	{
		periodCycles = VSCM_SYS_CLK / freq;
		dutyCycles = periodCycles * duty / 100;

		if(!dutyCycles)
			dutyCycles = 1;
		if(!periodCycles)
			periodCycles = 2;
	}
	if (!pulses)
		pulses = 0xFFFFFFFF;
	
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->PulserHigh, dutyCycles);
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->PulserPeriod, periodCycles);
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->PulserN, pulses);
	
	printf("Pulser setup (%u, %u)\n", periodCycles, dutyCycles);
}


/*analog playback*/
void
VSCMInitDACPulser(int id, int amp)
{
	int i, length = 128;
	double y1, y2;
	for(i = 0; i < length; i++)
	{
		y1 = 8192.0+amp;
		y2 = 8192.0+amp;
		if(i == 0 || i == (length-1))
			y1 = y2 = 8192.0;
		if (id == 1) {
			VSCM_WriteReg((unsigned int)&pVSCM_BASE->DacCh0, (i<<23) | ((length-1)<<14) | (unsigned int)y1);
		}
		else if (id == 2) {
			VSCM_WriteReg((unsigned int)&pVSCM_BASE->DacCh1, (i<<23) | ((length-1)<<14) | (unsigned int)y2);
		}
/*		if (i % 2)
			amp += 2;
		else
			amp += 3;
*/	}
}


void
VSCMInitSquareWave(int amp, int num_pulses)
{
	unsigned int periodCycles = VSCM_SYS_CLK / 200000;
	unsigned int dutyCycles = periodCycles / 2;
	int i, length = 128;
	unsigned int val, unum;

	/* Convert amplitude to DAC units */
	amp /= 0.139;

	if (!num_pulses)
		unum = 0xFFFFFFFF;
	else
		unum = (unsigned int)num_pulses;

	VSCM_WriteReg((unsigned int)&pVSCM_BASE->DacCfg, (8192 << 16));

	VSCM_WriteReg((unsigned int)&pVSCM_BASE->PulserHigh, dutyCycles);
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->PulserPeriod, periodCycles);
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->PulserN, unum);

	for(i = 0; i < length; i++)
	{
		if (i == 0 || i == (length - 1))
			val = 8192;
		else
			val = 8192 + amp;

		VSCM_WriteReg((unsigned int)&pVSCM_BASE->DacCh0, (i << 23) | ((length - 1) << 14) | val);
		VSCM_WriteReg((unsigned int)&pVSCM_BASE->DacCh1, (i << 23) | ((length - 1) << 14) | val);
	}
	/*	VSCM_WriteReg((unsigned int)&pVSCM_BASE->FssrSerClk, 0);*/
}

void
VSCMInitSawWave(int amp, int num_pulses)
{
	unsigned int periodCycles = VSCM_SYS_CLK / 250000;
	unsigned int dutyCycles = periodCycles / 2;
	int i, length = 500;
	unsigned int val, unum;

	/* Convert amplitude to DAC units */
	amp /= 0.139;

	if (!num_pulses)
		unum = 0xFFFFFFFF;
	else
		unum = (unsigned int)num_pulses;

	VSCM_WriteReg((unsigned int)&pVSCM_BASE->PulserHigh, dutyCycles);
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->PulserPeriod, periodCycles);
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->PulserN, unum);

	for(i = 0; i < length; i++)
	{
		if (i == 0 || i == (length - 1))
			val = 8192;
		else
			val = 8192 + (-((float)amp / length) * i + amp);

		VSCM_WriteReg((unsigned int)&pVSCM_BASE->DacCh0, (i << 23) | ((length - 1) << 14) | val);
		VSCM_WriteReg((unsigned int)&pVSCM_BASE->DacCh1, (i << 23) | ((length - 1) << 14) | val);
	}
}

void
VSCMInitSensorWave(int amp, int freq, int num_pulses)
{
	unsigned int periodCycles, dutyCycles;
	int i, length = 20;
	unsigned int val, unum;

	if (!freq)
		freq = 200000;

	periodCycles = VSCM_SYS_CLK / freq;
	dutyCycles = periodCycles / 2;
	
	/* Convert amplitude to DAC units */
	amp /= 0.1239;

	if (!num_pulses)
		unum = 0xFFFFFFFF;
	else
		unum = (unsigned int)num_pulses;

	VSCM_WriteReg((unsigned int)&pVSCM_BASE->PulserHigh, dutyCycles);
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->PulserPeriod, periodCycles);
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->PulserN, unum);

	VSCM_WriteReg((unsigned int)&pVSCM_BASE->DacCh0, (1 << 23) | ((1) << 14) | 8192 + amp);
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->DacCh1, (1 << 23) | ((1) << 14) | 8192 + amp);
}



/**/
void
DisableTrig()
{
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->Trigger, IO_MUX_0);
}

/**/
void
EnableTrig()
{
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->Trigger, IO_MUX_FPINPUT0);
}






/*calls in 'Download'
 VSCMReadoutFIFO
 VSCMPulseFPOuput(0)
*/
void
VSCMInit()
{
	unsigned int i;
	int amp = 5000;

#ifdef VXWORKS
	sysBusToLocalAdrs(0x39, VSCM_BASE_ADDR, &pVSCM_BASE);
	sysBusToLocalAdrs(0x09, VSCM_BASE_ADDR_A32, &pVSCMFifo);
#else
	vmeBusToLocalAdrs(0x39, VSCM_BASE_ADDR, &pVSCM_BASE);
	vmeBusToLocalAdrs(0x09, VSCM_BASE_ADDR_A32, &pVSCMFifo);
#endif	

	printf("\nInitializing VSCM\n");
	printf("VSCM Firmware Revision: %d.%d\n", VSCM_ReadReg((unsigned int)&pVSCM_BASE->FirmwareRev) >> 8, VSCM_ReadReg((unsigned int)&pVSCM_BASE->FirmwareRev) & 0xFF);
	printf("VSCM Board Id: 0x%08X\n", VSCM_ReadReg((unsigned int)&pVSCM_BASE->BoardId));

	/* Load default pulser waveform*/
	VSCMInitDACPulser(1, amp);
	VSCMInitDACPulser(2, amp);


	/* Front-panel I/O setup*/
	VSCM_SetupPulser(1000, 50, 0xffffffff);	/* Digital pulser, 1kHz*/
	VSCMPulseFPOuput(0);

	/*	VSCM_WriteReg((unsigned int)&pVSCM_BASE->Trigger, IO_MUX_0);*/

    /*trigger from the front panel input (bottom right)*/ 
	/*VSCM_WriteReg((unsigned int)&pVSCM_BASE->Trigger, IO_MUX_FPINPUT0);*/
    /*trigger from SD*/
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->Trigger, IO_MUX_SWB_TRIG1);


	VSCM_WriteReg((unsigned int)&pVSCM_BASE->DACTrigger, /*IO_MUX_FPINPUT0*/IO_MUX_SWB_TRIG1);
	/*	VSCM_WriteReg((unsigned int)&pVSCM_BASE->DACTrigger, IO_MUX_PULSER);*/
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->FpOutput[0], /*IO_MUX_0*/IO_MUX_SWB_TRIG1 | (256<<16)/*(384<<16)*/);
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->FpOutput[1], IO_MUX_FPINPUT0);
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->FpOutput[2], IO_MUX_FPINPUT0 | (384<<16));
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->FpOutput[3], IO_MUX_FPINPUT0 | (384<<16));

	/*trigger input delay*/
    VSCM_WriteReg((unsigned int)&pVSCM_BASE->FpInput[0], 0/*(374<<16)*/);

	/* Event readout setup*/
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->AD32, ((VSCM_BASE_ADDR_A32>>16) & 0xFF80) | 0x0001);
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->BlockCfg, 1);
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->ReadoutCfg, 1);
	
	/* FSSR Clock & Triggering setup*/
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->ClockCfg, 0);
	VSCMSetBCOClockFreq(BCO_FREQ_4MHZ);
	VSCM_SetupTriggerWindow(768/*768*/, 768/*768*/, BCO_FREQ_4MHZ);	/* 2us window capture, 4us lookback*/
	
		
	/* VME DMA setup (Universe or Tempe chipsets)*/
	/*
	VME_DMAInit();
	VME_DMAMode(DMA_MODE_BLK32);
	*/
}

/*calls in 'Prestart'*/
void
VSCMClear()
{
	/* Clear event buffers*/
	VSCM_WriteReg((unsigned int)&pVSCM_BASE->Reset, 1);
	
	/* Issue S/W sync: comment out if hardware sync is expected*/
	VSCM_SWSync(); 
	
	/*	VSCM_SetupPulser(1, 50);*/		/* 1Hz, 50% duty*/
	taskDelay(10);
	
	/* Initialize FSSR2 chips*/
	FSSR_Init();

	/*	DMA_MODE_BLK32
		DMA_MODE_BLK64
		DMA_MODE_2eVME64
		DMA_MODE_2eSST64	*/
}




/*PRBALL*/

void
FSSR_StatAll()
{
  VSCMStat();
  printf("\n\n\n Reading Status of VCSM & HFCB #1 & 2 \n");
  VSCM_FSSRStatus(0);   
  VSCM_FSSRStatus(1);
  VSCM_FSSRStatus(2);
  VSCM_FSSRStatus(3);
  VSCM_FSSRStatus(4);   
  VSCM_FSSRStatus(5);
  VSCM_FSSRStatus(6);
  VSCM_FSSRStatus(7);
}

void
FSSR_StatHFCB1()
{
  printf("\n\n\n Reading Status of VCSM & HFCB #1 \n");
  VSCMStat();
  VSCM_FSSRStatus(0);   
  VSCM_FSSRStatus(1);
  VSCM_FSSRStatus(2);
  VSCM_FSSRStatus(3);
 printf(" \n\n\n");
}

void
FSSR_StatHFCB2()
{
  printf("\n\n\n Reading Status of VCSM & HFCB #2 \n");
  VSCMStat();
  VSCM_FSSRStatus(4);   
  VSCM_FSSRStatus(5);
  VSCM_FSSRStatus(6);
  VSCM_FSSRStatus(7);
  printf("\n\n\n");
}

void
FSSR_StatHT3()
{
  printf("\n\n\n Reading Status of VCSM & HT3 on HFCB connector #1 \n");
  VSCMStat();
  VSCM_FSSRStatus(1);   
  VSCM_FSSRStatus(2);
 printf(" \n\n\n");
}

void
VSCM_ClearandStart_Triggers()
{
  printf(" \n\n\n");
  VSCMStat(); 
  printf("\n\n\n Pulser Starting \n");
  VSCM_WriteReg((unsigned int)&pVSCM_BASE->Reset, 1);
  VSCM_WriteReg((unsigned int)&pVSCM_BASE->PulserStart, 1);
  VSCMStat();  
  printf(" \n\n\n");
}
  



#else /* dummy version*/

void
vscm_dummy()
{
  return;
}

#endif
