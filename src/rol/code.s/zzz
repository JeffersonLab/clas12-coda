14c14
<  *  SVN: $Rev: 529 $
---
>  *  SVN: $Rev: 488 $
15a16,17
>  * Sergey: Sep 12, 2011:
>  *    copied from /site/coda/2.6.1/extencions/fadcV2 and adjusted slightly
17a20,21
> #if defined(VXWORKS) || defined(Linux_vme)
> 
20c24
< #include "vxCompat.h"
---
> /*#include "vxCompat.h"*/
39d42
< #define HPS
64a68
> /*
66a71
> */
102d106
< int fadcBlockError=0;       /* Whether (1) or not (0) Block Transfer had an error */
105c109
< #include "fadcFirmwareTools.c"
---
> #include "cinclude/fadcFirmwareTools.c"
145c149
<  *      bit 16:  Exit before board initialization
---
>  *       bit 16:  Exit before board initialization
149c153
<  *      bit 17:  Use fadcAddrList instead of addr and addr_inc
---
>  *       bit 17:  Use fadcAddrList instead of addr and addr_inc
153,154c157
<  *      
<  *
---
> *
161c164
<   int ii, res, errFlag = 0;
---
>   int ii, res, rdata, errFlag = 0;
166c169
<   unsigned int rdata, laddr, laddr_inc, a32addr, a16addr=0;
---
>   unsigned int laddr, a32addr, a16addr=0;
170c173
<   int useList=0;
---
>   
183,185d185
<   /* Check if we're initializing using a list */
<   useList=(iFlag&(1<<17))>>17;
< 
199c199
<       if( ((addr_inc==0)||(nadc==0)) && (useList==0) )
---
>       if((addr_inc==0)||(nadc==0))
229,237c229
<       if(useList==1)
< 	{
< 	  laddr_inc = fadcAddrList[ii] + fadcA24Offset;
< 	}
<       else
< 	{
< 	  laddr_inc = laddr +ii*addr_inc;
< 	}
<       fa = (struct fadc_struct *)laddr_inc;
---
>       fa = (struct fadc_struct *)(laddr + ii*addr_inc);
250c242
< 		 (UINT32) laddr_inc-fadcA24Offset, (UINT32) fa);
---
> 		 (UINT32) addr + ii*addr_inc, (UINT32) fa);
260,262c252,253
< 	      printf(" ERROR: For board at 0x%x, Invalid Board ID: 0x%x\n",
< 		     (UINT32) fa, rdata);
< /* 	      return(ERROR); */
---
> 	      printf(" ERROR: Invalid Board ID: 0x%x\n",rdata);
> 	      return(ERROR);
267c258
< 	      | ((rdata&FA_VERSION_MASK)==0x08) | ((rdata&FA_VERSION_MASK)==0x09) )
---
> 	      | ((rdata&FA_VERSION_MASK)==0x08) )
276,277c267
< 	      continue;
< /* 	      return(ERROR); */
---
> 	      return(ERROR);
279c269
< 	  FAp[boardID] = (struct fadc_struct *)(laddr_inc);
---
> 	  FAp[boardID] = (struct fadc_struct *)(laddr + ii*addr_inc);
286,288c276,277
< 	  printf("Initialized FADC %2d  Slot # %2d at address 0x%08x (0x%08x) \n",
< 		 nfadc,fadcID[nfadc],(UINT32) FAp[(fadcID[nfadc])],
< 		 (UINT32) FAp[(fadcID[nfadc])]-fadcA24Offset);
---
> 	  printf("Initialized FADC %2d  Slot # %2d at address 0x%08x \n",
> 		 nfadc,fadcID[nfadc],(UINT32) FAp[(fadcID[nfadc])]);
541d529
< /* #ifdef USEMGTCTRL */
543d530
<       vmeWrite32(&(FAp[fadcID[ii]]->mgt_ctrl),FA_MGT_RESET);
545,546d531
<       vmeWrite32(&(FAp[fadcID[ii]]->mgt_ctrl),FA_MGT_RESET);
< /* #endif */
646,663d630
< /*******************************************************************************
<  *
<  * faSetClockSource - Set the clock source
<  *
<  *   This routine should be used in the case that the source clock
<  *   is NOT set in faInit (and defaults to Internal).  Such is the case
<  *   when clocks are synchronized in a many crate system.  The clock source
<  *   of the FADC should ONLY be set AFTER those clocks have been set and
<  *   synchronized.
<  *
<  *   clkSrc: 2 bit integer
<  *       bits 1-0:  defines Clock Source
<  *           0 0  Internal 250MHz Clock
<  *           0 1  Front Panel 
<  *           1 0  VXS (P0)
<  *           1 1  VXS (P0)
<  *
<  */
665,714d631
< int
< faSetClockSource(int id, int clkSrc)
< {
<   if(id==0) id=fadcID[0];
< 
<   if((id<=0) || (id>21) || (FAp[id] == NULL)) 
<     {
<       printf("faStatus: ERROR : ADC in slot %d is not initialized \n",id);
<       return;
<     }
< 
<   if(clkSrc>0x3)
<     {
<       printf("%s: ERROR: Invalid Clock Source specified (0x%x)\n",
< 	     __FUNCTION__,clkSrc);
<       return ERROR;
<     }
< 
<   /* Enable Clock source - Internal Clk enabled by default */ 
<   vmeWrite32(&(FAp[id]->ctrl1),
< 	     (vmeRead32(&FAp[id]->ctrl1) & ~(FA_REF_CLK_MASK)) |
< 	     (clkSrc | FA_ENABLE_INTERNAL_CLK)) ;
<   taskDelay(20);
< 
<   switch(clkSrc)
<     {
<     case FA_REF_CLK_INTERNAL:
<       printf("%s: FADC id %d clock source set to INTERNAL\n",
< 	     __FUNCTION__,id);
<       break;
< 
<     case FA_REF_CLK_FP:
<       printf("%s: FADC id %d clock source set to FRONT PANEL\n",
< 	     __FUNCTION__,id);
<       break;
< 
<     case FA_REF_CLK_P0:
<       printf("%s: FADC id %d clock source set to VXS (P0)\n",
< 	     __FUNCTION__,id);
<       break;
< 
<     case FA_REF_CLK_MASK:
<       printf("%s: FADC id %d clock source set to VXS (P0)\n",
< 	     __FUNCTION__,id);
<       break;
<     }
< 
<   return OK;
< }
< 
759,766c676,683
<     {
<       adcStat[ii] = (vmeRead32(&(FAp[id]->adc_status[ii]))&0xFFFF);
<       adcConf[ii] = (vmeRead32(&(FAp[id]->adc_config[ii]))&0xFFFF);
<     }    
<   PTW =  (vmeRead32(&(FAp[id]->adc_ptw))&0xFFFF)*FA_ADC_NS_PER_CLK;
<   PL  =  (vmeRead32(&(FAp[id]->adc_pl))&0xFFFF)*FA_ADC_NS_PER_CLK;
<   NSB =  (vmeRead32(&(FAp[id]->adc_nsb))&0xFFFF)*FA_ADC_NS_PER_CLK;
<   NSA =  (vmeRead32(&(FAp[id]->adc_nsa))&0xFFFF)*FA_ADC_NS_PER_CLK;
---
>   {
>       adcStat[ii] = vmeRead32(&(FAp[id]->adc_status[ii]));
>       adcConf[ii] = vmeRead32(&(FAp[id]->adc_config[ii]));
>   }    
>   PTW =  (vmeRead32(&(FAp[id]->adc_ptw))&0xffff)*FA_ADC_NS_PER_CLK;
>   PL  =  (vmeRead32(&(FAp[id]->adc_pl))&0xffff)*FA_ADC_NS_PER_CLK;
>   NSB =  (vmeRead32(&(FAp[id]->adc_nsb))&0xffff)*FA_ADC_NS_PER_CLK;
>   NSA =  (vmeRead32(&(FAp[id]->adc_nsa))&0xffff)*FA_ADC_NS_PER_CLK;
1117,1137d1033
< /*
<  * faWaitForAdcReady()
<  *   - Static routine, to wait for the ADC processing chip ready bit
<  *     before proceeding with further programming
<  *
<  */
< static void
< faWaitForAdcReady(int id)
< {
<   int iwait=0;
< 
<   while((iwait<100) && (vmeRead32(&FAp[id]->adc_status[0])&0x8000)==0)
<     {
<       iwait++;
<     }
< 
<   if(iwait==100)
<     printf("%s: ERROR: Wait timeout.\n",__FUNCTION__);
< 
< }
< 
1154d1049
<   faWaitForAdcReady(id);
1156d1050
<   faWaitForAdcReady(id);
1158d1051
<   faWaitForAdcReady(id);
1160,1161c1053
< 
<   faWaitForAdcReady(id);
---
> 	    
1163d1054
<   faWaitForAdcReady(id);
1165d1055
<   faWaitForAdcReady(id);
1168,1174c1058,1060
<   /* 01dec2011 This portion commented out... would change the input gain */
< /*   faWaitForAdcReady(id); */
< /*   vmeWrite32(&FAp[id]->adc_config[3], 0x1811); */
< /*   faWaitForAdcReady(id); */
< /*   vmeWrite32(&FAp[id]->adc_config[2], 0x40); */
< /*   faWaitForAdcReady(id); */
< /*   vmeWrite32(&FAp[id]->adc_config[2], 0xC0);	 */
---
>   /*	    vmeWrite32(&FAp[id]->adc_config[3], 0x1811);   */
>   vmeWrite32(&FAp[id]->adc_config[2], 0x40);
>   vmeWrite32(&FAp[id]->adc_config[2], 0xC0);	
1176d1061
<   faWaitForAdcReady(id);
1178d1062
<   faWaitForAdcReady(id);
1180d1063
<   faWaitForAdcReady(id);
1186d1068
<   faWaitForAdcReady(id);
1188d1069
<   faWaitForAdcReady(id);
1190d1070
<   faWaitForAdcReady(id);
1193d1072
<   faWaitForAdcReady(id);
1195d1073
<   faWaitForAdcReady(id);
1197d1074
<   faWaitForAdcReady(id);
1248,1251d1124
<   rval = vmeRead32(&FAp[id]->adc_test_data);
<   if(rval != sdata[(nsamples-2)])
< 	printf("faSetPPG: ERROR: Write error %x != %x\n",
< 	       rval, sdata[nsamples-2]);
1253,1256d1125
<   rval = vmeRead32(&FAp[id]->adc_test_data);
<   if(rval != sdata[(nsamples-1)])
< 	printf("faSetPPG: ERROR: Write error %x != %x\n",
< 	       rval, sdata[nsamples-1]);
1258,1260d1126
< /*   vmeWrite32(&FAp[id]->adc_test_data, (sdata[(nsamples-2)]&FA_PPG_SAMPLE_MASK)); */
< /*   vmeWrite32(&FAp[id]->adc_test_data, (sdata[(nsamples-1)]&FA_PPG_SAMPLE_MASK)); */
<     
1272,1274c1138,1140
<   
<   FALOCK;
<   val1 = (vmeRead32(&FAp[id]->adc_config[0])&0xFFFF);
---
> 
>  FALOCK;
>   val1 = vmeRead32(&FAp[id]->adc_config[0]);
1295c1161
<   val1 = (vmeRead32(&FAp[id]->adc_config[0])&0xFFFF);
---
>   val1 = vmeRead32(&FAp[id]->adc_config[0]);
1405,1408c1271,1274
<     {
<       logMsg("faReadBlock: ERROR : FADC in slot %d is not initialized \n",id,0,0,0,0,0);
<       return(ERROR);
<     }
---
>   {
>     logMsg("faReadBlock: ERROR : FADC in slot %d is not initialized \n",id,0,0,0,0,0);
>     return(ERROR);
>   }
1411,1414c1277,1280
<     {
<       logMsg("faReadBlock: ERROR: Invalid Destination address\n",0,0,0,0,0,0);
<       return(ERROR);
<     }
---
>   {
>     logMsg("faReadBlock: ERROR: Invalid Destination address\n",0,0,0,0,0,0);
>     return(ERROR);
>   }
1416d1281
<   fadcBlockError=0;
1422c1287
<     { /* Block Transfers */
---
>   { /* Block Transfers */
1424,1425c1289,1290
<       /*Assume that the DMA programming is already setup. */
<       /* Don't Bother checking if there is valid data - that should be done prior
---
>     /*Assume that the DMA programming is already setup. */
>     /* Don't Bother checking if there is valid data - that should be done prior
1428,1429c1293,1294
<       /* Check for 8 byte boundary for address - insert dummy word (Slot 0 FADC Dummy DATA)*/
<       if((unsigned long) (data)&0x7) 
---
>     /* Check for 8 byte boundary for address - insert dummy word (Slot 0 FADC Dummy DATA)*/
>     if((unsigned long) (data)&0x7) 
1439c1304
<       else 
---
>     else 
1445,1446c1310,1311
<       FALOCK;
<       if(rmode == 2) 
---
>     FALOCK;
>     if(rmode == 2) 
1449,1453c1314,1318
< 	    {
< 	      logMsg("faReadBlock: ERROR: FADC in slot %d is not First Board\n",id,0,0,0,0,0);
< 	      FAUNLOCK;
< 	      return(ERROR);
< 	    }
---
> 	  {
> 	    logMsg("faReadBlock: ERROR: FADC in slot %d is not First Board\n",id,0,0,0,0,0);
> 	    FAUNLOCK;
> 	    return(ERROR);
> 	  }
1456c1321
<       else
---
>     else
1460,1465c1325,1331
< #ifdef VXWORKS
<       retVal = sysVmeDmaSend((UINT32)laddr, vmeAdr, (nwrds<<2), 0);
< #else
<       retVal = vmeDmaSend((UINT32)laddr, vmeAdr, (nwrds<<2));
< #endif
<       if(retVal |= 0) 
---
> 
>     retVal = usrVme2MemDmaStart(vmeAdr, (UINT32)laddr, (nwrds<<2));
> 	/*
> logMsg("vmeAdr=0x%08x, laddr=0x%08x, nwrds=%d, retVal=%d\n",vmeAdr,laddr,nwrds,retVal,5,6);
> 	*/
> 
>     if(retVal |= 0) 
1472c1338
<       if(async) 
---
>     if(async) 
1477c1343
<       else
---
>     else
1480,1484c1346,1351
< #ifdef VXWORKS
< 	  retVal = sysVmeDmaDone(10000,1);
< #else
< 	  retVal = vmeDmaDone();
< #endif
---
> 
> 	  retVal = usrVme2MemDmaDone();
> 	  /*
> 	  logMsg("done: retVal=%d words\n",(retVal>>2),2,3,4,5,6);
> 	  */
> 
1487c1354
<       if(retVal > 0) 
---
>     if(retVal > 0) 
1491,1494c1358,1361
< 	    {
< 	      csr = vmeRead32(&(FAp[fadcMaxSlot]->csr));  /* from Last FADC */
< 	      stat = (csr)&FA_CSR_BERR_STATUS;  /* from Last FADC */
< 	    }
---
> 	  {
>         csr = vmeRead32(&(FAp[fadcMaxSlot]->csr));  /* from Last FADC */
> 	    stat = (csr)&FA_CSR_BERR_STATUS;  /* from Last FADC */
> 	  }
1496,1526c1363,1384
< 	    {
< 	      csr = vmeRead32(&(FAp[id]->csr));  /* from Last FADC */
< 	      stat = (csr)&FA_CSR_BERR_STATUS;  /* from Last FADC */
< 	    }
< 	  if((retVal>0) && (stat)) 
< 	    {
< #ifdef VXWORKS
< 	      xferCount = (nwrds - (retVal>>2) + dummy);  /* Number of Longwords transfered */
< #else
< 	      xferCount = ((retVal>>2) + dummy);  /* Number of Longwords transfered */
< 	      /* 	xferCount = (retVal + dummy);  /\* Number of Longwords transfered *\/ */
< #endif
< 	      FAUNLOCK;
< 	      return(xferCount); /* Return number of data words transfered */
< 	    }
< 	  else
< 	    {
< #ifdef VXWORKS
< 	      xferCount = (nwrds - (retVal>>2) + dummy);  /* Number of Longwords transfered */
< #else
< 	      xferCount = ((retVal>>2) + dummy);  /* Number of Longwords transfered */
< #endif
< 	      logMsg("faReadBlock: DMA transfer terminated by unknown BUS Error (csr=0x%x xferCount=%d id=%d)\n",
< 		     csr,xferCount,id,0,0,0);
< 	      FAUNLOCK;
< 	      fadcBlockError=1;
< 	      return(xferCount);
< 	      /* 	return(ERROR); */
< 	    }
< 	} 
<       else if (retVal == 0)
---
>       {
>         csr = vmeRead32(&(FAp[id]->csr));  /* from Last FADC */
>         stat = (csr)&FA_CSR_BERR_STATUS;  /* from Last FADC */
>       }
>       if((retVal>0) && (stat)) 
>       {
>         xferCount = ((retVal>>2) + dummy);  /* Number of Longwords transfered */
>         FAUNLOCK;
>   	  /*logMsg("111 %d\n",dummy,2,3,4,5,6);*/
>         return(xferCount); /* Return number of data words transfered */
>       }
>       else
>       {
>         xferCount = ((retVal>>2) + dummy);  /* Number of Longwords transfered */
>         logMsg("faReadBlock: DMA transfer terminated by unknown BUS Error (csr=0x%x xferCount=%d)\n",csr,xferCount,0,0,0,0);
>         FAUNLOCK;
>         /*logMsg("222 %d\n",dummy,2,3,4,5,6);*/
> 	    return(xferCount);
> 	    /* 	return(ERROR); */
> 	  }
>     } 
>     else if (retVal == 0)
1528,1535c1386,1388
< #ifdef VXWORKS
< 	  logMsg("faReadBlock: WARN: DMA transfer terminated by word count 0x%x\n",nwrds,0,0,0,0,0);
< #else
< 	  logMsg("faReadBlock: WARN: DMA transfer returned zero word count 0x%x\n",nwrds,0,0,0,0,0);
< #endif
< 	  FAUNLOCK;
< 	  fadcBlockError=1;
< 	  return(nwrds);
---
>       logMsg("faReadBlock: WARN: DMA transfer terminated by word count 0x%x\n",nwrds,0,0,0,0,0);
>       FAUNLOCK;
>       return(nwrds);
1537,1539c1390,1391
<       else 
< 	{  /* Error in DMA */
< #ifdef VXWORKS
---
>     else 
>     {  /* Error in DMA */
1541,1543d1392
< #else
< 	  logMsg("faReadBlock: ERROR: vmeDmaDone returned an Error\n",0,0,0,0,0,0);
< #endif
1545,1547c1394,1395
< 	  fadcBlockError=1;
< 	  return(retVal>>2);
< 	}
---
>       return(retVal>>2);
>     }
1549c1397
<     } 
---
>   } 
1551c1399
<     {  /*Programmed IO */
---
>   {  /*Programmed IO */
1553,1557c1401,1405
<       /* Check if Bus Errors are enabled. If so then disable for Prog I/O reading */
<       FALOCK;
<       berr = vmeRead32(&(FAp[id]->ctrl1))&FA_ENABLE_BERR;
<       if(berr)
< 	vmeWrite32(&(FAp[id]->ctrl1),vmeRead32(&(FAp[id]->ctrl1)) & ~FA_ENABLE_BERR);
---
>     /* Check if Bus Errors are enabled. If so then disable for Prog I/O reading */
>     FALOCK;
>     berr = vmeRead32(&(FAp[id]->ctrl1))&FA_ENABLE_BERR;
>     if(berr)
> 	    vmeWrite32(&(FAp[id]->ctrl1),vmeRead32(&(FAp[id]->ctrl1)) & ~FA_ENABLE_BERR);
1559,1561c1407,1409
<       dCnt = 0;
<       /* Read Block Header - should be first word */
<       bhead = (unsigned int) *FApd[id]; 
---
>     dCnt = 0;
>     /* Read Block Header - should be first word */
>     bhead = (unsigned int) *FApd[id]; 
1563c1411
<       bhead = LSWAP(bhead);
---
>     bhead = LSWAP(bhead);
1565,1567c1413,1416
<       if((bhead&FA_DATA_TYPE_DEFINE)&&((bhead&FA_DATA_TYPE_MASK) == FA_DATA_BLOCK_HEADER)) {
< 	blknum = bhead&FA_DATA_BLKNUM_MASK;
< 	ehead = (unsigned int) *FApd[id];
---
>     if((bhead&FA_DATA_TYPE_DEFINE)&&((bhead&FA_DATA_TYPE_MASK) == FA_DATA_BLOCK_HEADER))
>     {
> 	  blknum = bhead&FA_DATA_BLKNUM_MASK;
> 	  ehead = (unsigned int) *FApd[id];
1569c1418
< 	ehead = LSWAP(ehead);
---
>       ehead = LSWAP(ehead);
1571c1420
< 	evnum1 = ehead&FA_DATA_TRIGNUM_MASK;
---
> 	  evnum1 = ehead&FA_DATA_TRIGNUM_MASK;
1573c1422
< 	data[dCnt] = bhead;
---
> 	  data[dCnt] = bhead;
1575c1424
< 	data[dCnt] = LSWAP(bhead); /* Swap back to little-endian */
---
>       data[dCnt] = LSWAP(bhead); /* Swap back to little-endian */
1577c1426
< 	dCnt++;
---
>       dCnt++;
1579c1428
< 	data[dCnt] = ehead;
---
>       data[dCnt] = ehead;
1581c1430
< 	data[dCnt] = LSWAP(ehead); /* Swap back to little-endian */
---
>       data[dCnt] = LSWAP(ehead); /* Swap back to little-endian */
1583,1586c1432,1435
< 	dCnt++;
<       }
<       else
< 	{
---
>       dCnt++;
>     }
>     else
>     {
1589,1600c1438,1449
< 	    {
< 	      logMsg("faReadBlock: FIFO Empty (0x%08x)\n",bhead,0,0,0,0,0);
< 	      FAUNLOCK;
< 	      return(0);
< 	    } 
< 	  else 
< 	    {
< 	      logMsg("faReadBlock: ERROR: Invalid Header Word 0x%08x\n",bhead,0,0,0,0,0);
< 	      FAUNLOCK;
< 	      return(ERROR);
< 	    }
< 	}
---
>       {
>         logMsg("faReadBlock: FIFO Empty (0x%08x)\n",bhead,0,0,0,0,0);
>         FAUNLOCK;
>         return(0);
>       } 
>       else 
>       {
>         logMsg("faReadBlock: ERROR: Invalid Header Word 0x%08x\n",bhead,0,0,0,0,0);
>         FAUNLOCK;
>         return(ERROR);
>       }
>     }
1602,1606c1451,1455
<       ii=0;
<       while(ii<nwrds) 
< 	{
< 	  val = (unsigned int) *FApd[id];
< 	  data[ii+2] = val;
---
>     ii=0;
>     while(ii<nwrds) 
>     {
>       val = (unsigned int) *FApd[id];
>       data[ii+2] = val;
1608c1457
< 	  val = LSWAP(val);
---
>       val = LSWAP(val);
1610,1612c1459
< 	  if( (val&FA_DATA_TYPE_DEFINE) 
< 	      && ((val&FA_DATA_TYPE_MASK) == FA_DATA_BLOCK_TRAILER) )
< 	    break;
---
>       if( (val&FA_DATA_TYPE_DEFINE) && ((val&FA_DATA_TYPE_MASK) == FA_DATA_BLOCK_TRAILER) ) break;
1615,1616c1462,1463
<       ii++;
<       dCnt += ii;
---
>     ii++;
>     dCnt += ii;
1619,1621c1466,1468
<       if(berr)
< 	vmeWrite32(&(FAp[id]->ctrl1),
< 		  vmeRead32(&(FAp[id]->ctrl1)) | FA_ENABLE_BERR);
---
>     if(berr)
>         vmeWrite32(&(FAp[id]->ctrl1),
> 		    vmeRead32(&(FAp[id]->ctrl1)) | FA_ENABLE_BERR);
1623,1625c1470,1472
<       FAUNLOCK;
<       return(dCnt);
<     }
---
>     FAUNLOCK;
>     return(dCnt);
>   }
1660a1508,1509
> 	retVal = usrVme2MemDmaDone();
>   /*
1665a1515
>   */
1682c1532
< 	  xferCount = (nwrds - (retVal>>2) + dummy);  /* Number of Longwords transfered */
---
> 	  xferCount = (/*nwrds - */(retVal>>2) + dummy);  /* Number of Longwords transfered */
1688c1538
< 	  xferCount = (nwrds - (retVal>>2) + dummy);  /* Number of Longwords transfered */
---
> 	  xferCount = (/*nwrds - */(retVal>>2) + dummy);  /* Number of Longwords transfered */
1925,1929c1775,1776
<   if(iFlag==0)
<     {
<       a32addr = vmeRead32(&(FAp[id]->adr32));
<       addrMB  = vmeRead32(&(FAp[id]->adr_mb));
<     }
---
>   a32addr = vmeRead32(&(FAp[id]->adr32));
>   addrMB  = vmeRead32(&(FAp[id]->adr_mb));
1934,1938c1781,1782
<   if(iFlag==0)
<     {
<       vmeWrite32(&(FAp[id]->adr32),a32addr);
<       vmeWrite32(&(FAp[id]->adr_mb),addrMB);
<     }
---
>   vmeWrite32(&(FAp[id]->adr32),a32addr);
>   vmeWrite32(&(FAp[id]->adr_mb),addrMB);
1943,1959d1786
< void
< faSoftReset(int id)
< {
<   if(id==0) id=fadcID[0];
< 
<   if((id<=0) || (id>21) || (FAp[id] == NULL)) 
<     {
<       logMsg("faReset: ERROR : ADC in slot %d is not initialized \n",id,0,0,0,0,0);
<       return;
<     }
< 
<   FALOCK;
<   vmeWrite32(&(FAp[id]->csr),FA_CSR_SOFT_RESET);
<   FAUNLOCK;
<   
< }
< 
2230,2234d2056
< /* return Scan mask for all initialized FADCs */
< unsigned int
< faScanMask()
< {
<   int ifadc, id, dmask=0;
2236,2245d2057
<   for(ifadc=0; ifadc<nfadc; ifadc++)
<     {
<       id = fadcID[ifadc];
<       dmask |= (1<<id);
<     }
< 
<   return(dmask);
< }
< 
< 
2442,2449d2253
< /*************************************************************************************
<  *
<  *  faEnableTriggerOut - Enable trigger out for front panel or p0
<  * 
<  *   output = 0 for FP trigger out
<  *            1 for P0 trigger out
<  *            2 for FP and P0 trigger out
<  */
2451,2455d2254
< void
< faEnableTriggerOut(int id, int output)
< {
<   int bitset=0;
<   if(id==0) id=fadcID[0];
2457,2492d2255
<   if((id<=0) || (id>21) || (FAp[id] == NULL)) 
<     {
<       logMsg("faEnableBusError: ERROR : ADC in slot %d is not initialized \n",id,0,0,0,0,0);
<       return;
<     }
< 
<   if(output>2)
<     {
<       logMsg("faEnableTriggerOut: ERROR: output (%d) out of range.  Must be less than 3",
< 	     output,2,3,4,5,6);
<       return;
< 
<     }
< 
<   switch(output)
<     {
<     case 0:
<       bitset = FA_ENABLE_TRIG_OUT_FP;
<       break;
<     case 1:
<       bitset = FA_ENABLE_TRIG_OUT_P0;
<       break;
<     case 2:
<       bitset = FA_ENABLE_TRIG_OUT_FP | FA_ENABLE_TRIG_OUT_P0;
<       break;
< 	
<     }
<   FALOCK;
<   vmeWrite32(&(FAp[id]->ctrl1),
< 	    vmeRead32(&(FAp[id]->ctrl1)) | bitset );
<   FAUNLOCK;
< 
< 
< 
< }
< 
2795c2558
<       logMsg("faResetTriggerCount: ERROR : ADC in slot %d is not initialized \n",id,0,0,0,0,0);
---
>       logMsg("faPrintThreshold: ERROR : ADC in slot %d is not initialized \n",id,0,0,0,0,0);
2808a2572,2573
>   int ii;
>   unsigned int wvalue=0;
2810,2812d2574
<   int ii, doWrite=0;
<   unsigned int lovalue=0, hivalue=0;
< 
2816,2819c2578,2581
<     {
<       logMsg("faSetThreshold: ERROR : ADC in slot %d is not initialized \n",id,0,0,0,0,0);
<       return(ERROR);
<     }
---
>   {
>     logMsg("faSetThreshold: ERROR : ADC in slot %d is not initialized \n",id,0,0,0,0,0);
>     return(ERROR);
>   }
2824,2826c2586,2588
<   for(ii=0;ii<FA_MAX_ADC_CHANNELS;ii++) 
<     {
<       if(ii%2==0)
---
>   for(ii=0; ii<FA_MAX_ADC_CHANNELS; ii++) 
>   {
>     if(ii%2==0)
2828,2829c2590,2591
< 	  lovalue = (vmeRead16(&FAp[id]->adc_thres[ii]));
< 	  hivalue = (vmeRead16(&FAp[id]->adc_thres[ii+1]));
---
> 	  if((1<<ii)&chmask) wvalue |= ( tvalue << 16 );
> 	  if((1<<(ii+1))&chmask) wvalue |= tvalue;
2831,2848c2593,2595
< 	  if((1<<ii)&chmask)
< 	    {
< 	      lovalue = tvalue;
< 	      doWrite=1;
< 	    }
< 	  if((1<<(ii+1))&chmask)
< 	    {
< 	      hivalue = tvalue;
< 	      doWrite=1;
< 	    }
< 
< 	  if(doWrite)
< 	    vmeWrite32((unsigned int *)&(FAp[id]->adc_thres[ii]),
< 		       lovalue<<16 | hivalue);
< 
< 	  lovalue = 0; 
< 	  hivalue = 0;
< 	  doWrite=0;
---
> 	  printf("faSetThreshold: ch %d, wvalue=0x%08x\n",ii,wvalue);
> 	  vmeWrite32((unsigned int *)&(FAp[id]->adc_thres[ii]), wvalue);
> 	  wvalue=0;
2850c2597
<     }
---
>   }
2857c2604
< faPrintThreshold(int id)
---
> faSetThresholdAll(int id, unsigned short tvalue[16])
2860c2607
<   unsigned short tval[FA_MAX_ADC_CHANNELS];
---
>   unsigned int wvalue=0;
2865,2868c2612,2615
<     {
<       logMsg("faPrintThreshold: ERROR : ADC in slot %d is not initialized \n",id,0,0,0,0,0);
<       return(ERROR);
<     }
---
>   {
>     logMsg("faSetThresholdAll: ERROR : ADC in slot %d is not initialized \n",id,0,0,0,0,0);
>     return(ERROR);
>   }
2871,2881c2618,2620
<   for(ii=0;ii<FA_MAX_ADC_CHANNELS;ii++)
<     {
<       tval[ii] = vmeRead16(&(FAp[id]->adc_thres[ii]));
<     }
<   FAUNLOCK;
< 
< 
<   printf(" Threshold Settings for FADC in slot %d:",id);
<   for(ii=0;ii<FA_MAX_ADC_CHANNELS;ii++) 
<     {
<       if((ii%4)==0) 
---
>   for(ii=0; ii<FA_MAX_ADC_CHANNELS; ii++) 
>   {
>     if(ii%2==0)
2883,2888c2622,2623
< 	  printf("\n");
< 	}
<       printf("Chan %2d: %5d   ",(ii+1),tval[ii]);
<     }
<   printf("\n");
<   
---
> 	  wvalue |= (tvalue[ii] << 16);
> 	  wvalue |= tvalue[ii+1];
2890,2943c2625,2627
<   return(OK);
< }
< 
< 
< int
< faSetDAC(int id, unsigned short dvalue, unsigned short chmask)
< {
<   int ii, doWrite=0;
<   unsigned int lovalue=0, hivalue=0;
<   
<   if(id==0) id=fadcID[0];
<   
<   if((id<=0) || (id>21) || (FAp[id] == NULL)) 
<     {
<       logMsg("faSetDAC: ERROR : ADC in slot %d is not initialized \n",id,0,0,0,0,0);
<       return(ERROR);
<     }
<   
<   if(chmask==0) chmask = 0xffff;  /* Set All channels the same */
<   
<   if(dvalue>0xfff) 
<     {
<       logMsg("faSetDAC: ERROR : DAC value (%d) out of range (0-255) \n",
< 	     dvalue,0,0,0,0,0);
<       return(ERROR);
<     }
<   
<   FALOCK;
<   for(ii=0;ii<FA_MAX_ADC_CHANNELS;ii++)
<     {
< 
<       if(ii%2==0)
< 	{
< 	  lovalue = (vmeRead16(&FAp[id]->dac[ii]));
< 	  hivalue = (vmeRead16(&FAp[id]->dac[ii+1]));
< 
< 	  if((1<<ii)&chmask)
< 	    {
< 	      lovalue = dvalue&FA_DAC_VALUE_MASK;
< 	      doWrite=1;
< 	    }
< 	  if((1<<(ii+1))&chmask)
< 	    {
< 	      hivalue = (dvalue&FA_DAC_VALUE_MASK);
< 	      doWrite=1;
< 	    }
< 
< 	  if(doWrite)
< 	    vmeWrite32((unsigned int *)&(FAp[id]->dac[ii]), 
< 		       lovalue<<16 | hivalue);
< 
< 	  lovalue = 0; 
< 	  hivalue = 0;
< 	  doWrite=0;
---
> 	  printf("faSetThreshold: ch %d, wvalue=0x%08x\n",ii,wvalue);
> 	  vmeWrite32((unsigned int *)&(FAp[id]->adc_thres[ii]), wvalue);
> 	  wvalue=0;
2945,2946c2629
< 
<     }
---
>   }
2952,2953c2635,2636
< void
< faPrintDAC(int id)
---
> int
> faPrintThreshold(int id)
2956c2639
<   unsigned short dval[FA_MAX_ADC_CHANNELS];
---
>   unsigned short tval[FA_MAX_ADC_CHANNELS];
2961,2964c2644,2647
<     {
<       logMsg("faPrintDAC: ERROR : ADC in slot %d is not initialized \n",id,0,0,0,0,0);
<       return;
<     }
---
>   {
>     logMsg("faPrintThreshold: ERROR : ADC in slot %d is not initialized \n",id,0,0,0,0,0);
>     return(ERROR);
>   }
2968c2651,2653
<     dval[ii] = vmeRead16(&(FAp[id]->dac[ii])) & FA_DAC_VALUE_MASK;
---
>   {
>     tval[ii] = vmeRead16(&(FAp[id]->adc_thres[ii]));
>   }
2970,2972c2655,2657
<   
<   
<   printf(" DAC Settings for FADC in slot %d:",id);
---
> 
> 
>   printf(" Threshold Settings for FADC in slot %d:",id);
2974,2977c2659,2665
<     {
<       if((ii%4)==0) printf("\n");
<       printf("Chan %2d: %5d   ",(ii+1),dval[ii]);
<     }
---
>   {
>     if((ii%4)==0) 
> 	{
> 	  printf("\n");
> 	}
>     printf("chan %2d: threshold=%3d   ",(ii+1),tval[ii]);
>   }
2980d2667
< }
2982,3010d2668
< int
< faSetChannelPedestal(int id, unsigned int chan, unsigned int ped)
< {
<   if(id==0) id=fadcID[0];
< 
<   if((id<=0) || (id>21) || (FAp[id] == NULL)) 
<     {
<       logMsg("faSetChannelPedestal: ERROR : ADC in slot %d is not initialized \n",id,0,0,0,0,0);
<       return(ERROR);
<     }
< 
<   if(chan>16)
<     {
<       logMsg("faSetChannelPedestal: ERROR : Channel (%d) out of range (0-15) \n",
< 	     chan,0,0,0,0,0);
<       return(ERROR);
<     }
< 
<   if(ped>0xffff) 
<     {
<       logMsg("faSetChannelPedestal: ERROR : PED value (%d) out of range (0-65535) \n",
< 	     ped,0,0,0,0,0);
<       return(ERROR);
<     }
< 
<   FALOCK;
<   vmeWrite32(&FAp[id]->adc_pedestal[chan], ped);
<   FAUNLOCK;
< 
3014,3017d2671
< int
< faGetChannelPedestal(int id, unsigned int chan)
< {
<   unsigned int rval=0;
3019,3040c2673
<   if(id==0) id=fadcID[0];
< 
<   if((id<=0) || (id>21) || (FAp[id] == NULL)) 
<     {
<       logMsg("faSetChannelPedestal: ERROR : ADC in slot %d is not initialized \n",id,0,0,0,0,0);
<       return(ERROR);
<     }
< 
<   if(chan>16)
<     {
<       logMsg("faSetChannelPedestal: ERROR : Channel (%d) out of range (0-15) \n",
< 	     chan,0,0,0,0,0);
<       return(ERROR);
<     }
< 
<   FALOCK;
<   rval = vmeRead32(&FAp[id]->adc_pedestal[chan]) & FA_ADC_PEDESTAL_MASK;
<   FAUNLOCK;
< 
<   return(rval);
< }
< 
---
> /*sergey: set same pedestal for all channels, will change it later*/
3042c2675
< faSetMGTTestMode(int id, unsigned int mode)
---
> faSetPedestal(int id, unsigned int wvalue)
3044c2677
<   unsigned int rval=0, wval=0;
---
>   int ii;
3049,3053c2682,2685
<     {
<       printf("%s: ERROR : ADC in slot %d is not initialized \n",
< 	     __FUNCTION__,id);
<       return(ERROR);
<     }
---
>   {
>     logMsg("faSetPedestal: ERROR : ADC in slot %d is not initialized \n",id,0,0,0,0,0);
>     return(ERROR);
>   }
3055,3056d2686
< #define USEMGTCTRL
< #ifdef USEMGTCTRL
3058,3069c2688,2691
<   if(mode)
<     wval = (1<<1);
<   else
<     wval = 0;
<   // FIXME: Old way
< /*   rval = vmeRead32(&FAp[id]->mgt_ctrl); */
< /*   if(mode) */
< /*     wval = (1<<1); */
< /*   else */
< /*     wval = rval & ~(1<<1); */
< 
<   vmeWrite32(&FAp[id]->mgt_ctrl,wval);
---
>   for(ii=0; ii<FA_MAX_ADC_CHANNELS; ii++) 
>   {
> 	vmeWrite32((unsigned int *)&(FAp[id]->adc_pedestal[ii]),wvalue);
>   }
3072,3077d2693
<   printf("%s: mode=%d  rval = 0x%08x    wval = 0x%08x\n",__FUNCTION__,
< 	 mode, rval, wval);
< #else
<   printf("%s: Function disabled\n",__FUNCTION__);
< #endif
< 
3080,3096d2695
< 
< /**************************************************************************************
<  *
<  *  faReadScalers - Scaler Data readout routine
<  *        Readout the desired scalers (indicated by the channel mask), as well
<  *        as the timer counter.  The timer counter will be the last word
<  *        in the "data" array.
<  *
<  *    id     - Slot number of module to read
<  *    data   - local memory address to place data
<  *    chmask - Channel Mask (indicating which channels to read)
<  *    rflag  - Readout Flag
<  *            bit 0 - Latch Scalers before read
<  *            bit 1 - Clear Scalers after read
<  *
<  *   RETURNS the number of 32bit words read, or ERROR if unsuccessful.
<  */
3098c2697
< faReadScalers(int id, volatile unsigned int *data, unsigned int chmask, int rflag)
---
> faPrintPedestal(int id)
3100,3101c2699,2700
<   int doLatch=0, doClear=0, ichan=0;
<   int dCnt=0;
---
>   int ii;
>   unsigned int tval[FA_MAX_ADC_CHANNELS];
3106,3110c2705,2708
<     {
<       logMsg("faReadScalers: ERROR : ADC in slot %d is not initialized \n",
< 	     id,0,0,0,0,0);
<       return ERROR;
<     }
---
>   {
>     logMsg("faPrintPedestal: ERROR : ADC in slot %d is not initialized \n",id,0,0,0,0,0);
>     return(ERROR);
>   }
3112,3120d2709
<   if(rflag & ~(FA_SCALER_CTRL_MASK))
<     {
<       logMsg("faReadScalers: WARN : rflag (0x%x) has undefined bits \n",
< 	     rflag,0,0,0,0,0);
<     }
< 
<   doLatch = rflag&(1<<0);
<   doClear = rflag&(1<<1);
< 
3122,3124c2711,2715
<   if(doLatch)
<     vmeWrite32(&FAp[id]->scaler_ctrl,
< 	       FA_SCALER_CTRL_ENABLE | FA_SCALER_CTRL_LATCH);
---
>   for(ii=0; ii<FA_MAX_ADC_CHANNELS;ii++)
>   {
>     tval[ii] = vmeRead32(&(FAp[id]->adc_pedestal[ii]));
>   }
>   FAUNLOCK;
3126,3128c2717,2721
<   for(ichan=0; ichan<16; ichan++)
<     {
<       if( (1<<ichan) & chmask )
---
> 
>   printf(" Pedestal Settings for FADC in slot %d:",id);
>   for(ii=0;ii<FA_MAX_ADC_CHANNELS;ii++) 
>   {
>     if((ii%4)==0) 
3130,3131c2723
< 	  data[dCnt] = vmeRead32(&FAp[id]->scaler[ichan]);
< 	  dCnt++;
---
> 	  printf("\n");
3133,3136c2725,2727
<     }
<   
<   data[dCnt] =  vmeRead32(&FAp[id]->time_count);
<   dCnt++;
---
>     printf("chan %2d: %3d   ",(ii+1),tval[ii]);
>   }
>   printf("\n");
3138,3141c2729,2730
<   if(doClear)
<     vmeWrite32(&FAp[id]->scaler_ctrl,
< 	       FA_SCALER_CTRL_ENABLE | FA_SCALER_CTRL_RESET);
<   FAUNLOCK;
---
>   return(OK);
> }
3143d2731
<   return dCnt;
3145d2732
< }
3147,3158c2734
< /**************************************************************************************
<  *
<  *  faPrintScalers - Scaler Print Out routine
<  *        Print out the scalers as well as the timer counter.
<  *
<  *    id     - Slot number of module to read
<  *    rflag  - Printout Flag
<  *            bit 0 - Latch Scalers before read
<  *            bit 1 - Clear Scalers after read
<  *
<  *   RETURNS ok if successful , or ERROR if unsuccessful.
<  */
---
> 
3160c2736
< faPrintScalers(int id, int rflag)
---
> faSetDAC(int id, unsigned short dvalue, unsigned short chmask)
3162,3163c2738,2739
<   int doLatch=0, doClear=0, ichan=0;
<   unsigned int data[16], time_count;
---
>   int ii;
>   unsigned int wvalue=0;
3169,3171c2745,2746
<       logMsg("faPrintScalers: ERROR : ADC in slot %d is not initialized \n",
< 	     id,0,0,0,0,0);
<       return ERROR;
---
>       logMsg("faSetDAC: ERROR : ADC in slot %d is not initialized \n",id,0,0,0,0,0);
>       return(ERROR);
3174,3178c2749
<   if(rflag & ~(FA_SCALER_CTRL_MASK))
<     {
<       logMsg("faPrintScalers: WARN : rflag (0x%x) has undefined bits \n",
< 	     rflag,0,0,0,0,0);
<     }
---
>   if(chmask==0) chmask = 0xffff;  /* Set All channels the same */
3180,3181c2751,2756
<   doLatch = rflag&(1<<0);
<   doClear = rflag&(1<<1);
---
>     if(dvalue>0xfff) 
>       {
> 	logMsg("faSetDAC: ERROR : DAC value (%d) out of range (0-255) \n",
> 	       dvalue,0,0,0,0,0);
> 	return(ERROR);
>       }
3184,3188c2759
<   if(doLatch)
<     vmeWrite32(&FAp[id]->scaler_ctrl,
< 	       FA_SCALER_CTRL_ENABLE | FA_SCALER_CTRL_LATCH);
< 
<   for(ichan=0; ichan<16; ichan++)
---
>   for(ii=0;ii<FA_MAX_ADC_CHANNELS;ii++)
3190c2761,2769
<       data[ichan] = vmeRead32(&FAp[id]->scaler[ichan]);
---
>       if(ii%2==0) 
> 	{
> 	  if((1<<ii)&chmask) 
> 	    wvalue |= ((dvalue&FA_DAC_VALUE_MASK)<<16);
> 	  if((1<<(ii+1))&chmask) 
> 	    wvalue |= ((dvalue&FA_DAC_VALUE_MASK));
> 	  vmeWrite32((unsigned int *)&(FAp[id]->dac[ii]), wvalue);
> 	  wvalue = 0;
> 	}
3192,3197d2770
<   
<   time_count =  vmeRead32(&FAp[id]->time_count);
< 
<   if(doClear)
<     vmeWrite32(&FAp[id]->scaler_ctrl,
< 	       FA_SCALER_CTRL_ENABLE | FA_SCALER_CTRL_RESET);
3200,3211c2773
<   printf("%s: Scaler Counts\n",__FUNCTION__);
<   for(ichan=0; ichan<16; ichan++)
<     {
<       if( (ichan%4) == 0 )
< 	printf("\n");
< 
<       printf("%2d: %10d ",ichan,data[ichan]);
<     }
<   printf("\n  timer: %10d\n",time_count);
< 
<   return OK;
< 
---
>   return(OK);
3214,3215c2776,2777
< int
< faClearScalers(int id)
---
> void
> faPrintDAC(int id)
3217c2779,2780
<   if(id==0) id=fadcID[0];
---
>   int ii;
>   unsigned short dval[FA_MAX_ADC_CHANNELS];
3219,3237d2781
<   if((id<=0) || (id>21) || (FAp[id] == NULL)) 
<     {
<       logMsg("faClearScalers: ERROR : ADC in slot %d is not initialized \n",
< 	     id,0,0,0,0,0);
<       return ERROR;
<     }
< 
<   FALOCK;
<   vmeWrite32(&FAp[id]->scaler_ctrl,
< 	   FA_SCALER_CTRL_ENABLE | FA_SCALER_CTRL_RESET);
<   FAUNLOCK;
< 
<   return OK;
< }
< 
< 
< int
< faLatchScalers(int id)
< {
3242,3244c2786,2787
<       logMsg("faLatchScalers: ERROR : ADC in slot %d is not initialized \n",
< 	     id,0,0,0,0,0);
<       return ERROR;
---
>       logMsg("faPrintDAC: ERROR : ADC in slot %d is not initialized \n",id,0,0,0,0,0);
>       return;
3248,3249c2791,2792
<   vmeWrite32(&FAp[id]->scaler_ctrl,
< 	   FA_SCALER_CTRL_ENABLE | FA_SCALER_CTRL_LATCH);
---
>   for(ii=0;ii<FA_MAX_ADC_CHANNELS;ii++)
>     dval[ii] = vmeRead16(&(FAp[id]->dac[ii])) & FA_DAC_VALUE_MASK;
3251,3260c2794,2797
< 
<   return OK;
< }
< 
< int
< faEnableScalers(int id)
< {
<   if(id==0) id=fadcID[0];
< 
<   if((id<=0) || (id>21) || (FAp[id] == NULL)) 
---
>   
>   
>   printf(" DAC Settings for FADC in slot %d:",id);
>   for(ii=0;ii<FA_MAX_ADC_CHANNELS;ii++) 
3262,3264c2799,2800
<       logMsg("faEnableScalers: ERROR : ADC in slot %d is not initialized \n",
< 	     id,0,0,0,0,0);
<       return ERROR;
---
>       if((ii%4)==0) printf("\n");
>       printf("Chan %2d: %3d   ",(ii+1),dval[ii]);
3266,3271c2802,2803
< 
<   FALOCK;
<   vmeWrite32(&FAp[id]->scaler_ctrl,FA_SCALER_CTRL_ENABLE);
<   FAUNLOCK;
< 
<   return OK;
---
>   printf("\n");
>   
3274,3293d2805
< int
< faDisableScalers(int id)
< {
<   if(id==0) id=fadcID[0];
< 
<   if((id<=0) || (id>21) || (FAp[id] == NULL)) 
<     {
<       logMsg("faDisableScalers: ERROR : ADC in slot %d is not initialized \n",
< 	     id,0,0,0,0,0);
<       return ERROR;
<     }
< 
<   FALOCK;
<   vmeWrite32(&FAp[id]->scaler_ctrl,~FA_SCALER_CTRL_ENABLE);
<   FAUNLOCK;
< 
<   return OK;
< }
< 
< 
3299c2811
< #include "faItrig.c"
---
> #include "cinclude/faItrig.c"
3676,3681d3187
< #ifdef HPS
< void
< faWriteHPSConfig(int id, unsigned int config6, unsigned int config7)
< {
<   if(config6==0) config6 = 0x386;
<   if(config7==0) config7 = 0xa4;
3683,3777d3188
<   if(id==0) id=fadcID[0];
< 
<   if((id<=0) || (id>21) || (FAp[id] == NULL)) 
<     {
<       printf("%s: ERROR : ADC in slot %d is not initialized \n",__FUNCTION__,
< 	     id);
<       return;
<     }
< 
<   printf("%s: Writing 0x%x to FA%d config6\n",__FUNCTION__,
< 	 config6,id);
<   printf("%s: Writing 0x%x to FA%d config7\n",__FUNCTION__,
< 	 config7,id);
< 
<   FALOCK;
<   vmeWrite32(&(FAp[id]->config6),config6);
<   vmeWrite32(&(FAp[id]->config7),config7);
< 
<   config6 = vmeRead32(&(FAp[id]->config6));
<   config7 = vmeRead32(&(FAp[id]->config7));
<   FAUNLOCK;
< 
<   printf("%s: Readback config6 = 0x%x\n",__FUNCTION__,config6&0xffff);
<   printf("%s: Readback config7 = 0x%x\n",__FUNCTION__,config7&0xffff);
< 
< }
< 
< /**************************************************************************************
<  *
<  *  faSetHPSParameters - Set the parameters specific for HPS
<  *        These parameters can be set at any time, but would be
<  *        safest to set prior to a SYNC (by TI Master).
<  *
<  *    id     
<  *           - Slot number of module to read
<  *    tot    
<  *           - Time Over Threshold value for integration window
<  *             Value must be less than 4095
<  *    maxIntTime 
<  *           - The Maximum Integration time (in 16 ns steps)
<  *             Must be less than 8
<  *    sumScaleFactor 
<  *           - Scale Factor for the total sum reported to the CTP
<  *             i.e. Sum/(2^sumScaleFactor)
<  *             Must be less than 15
<  *
<  *   RETURNS OK if successful, otherwise ERROR
<  */
< 
< int
< faSetHPSParameters(int id, unsigned int tot, 
< 		   unsigned int maxIntTime, unsigned int sumScaleFactor)
< {
<   unsigned int config6=0, config7=0;
< 
<   if(id==0) id=fadcID[0];
< 
<   if((id<=0) || (id>21) || (FAp[id] == NULL)) 
<     {
<       printf("%s: ERROR : ADC in slot %d is not initialized \n",__FUNCTION__,
< 	     id);
<       return ERROR;
<     }
< 
<   if(tot>0x1000)
<     {
<       printf("%s: ERROR : Invalid value for tot (%d)\n", 
< 	     __FUNCTION__,tot);
<       return ERROR;
<     }
<   config6 = tot;
< 
<   if(maxIntTime>8)
<     {
<       printf("%s: ERROR: Invalid value for maxIntTime (%d).  Must be less than 8.\n",
< 	     __FUNCTION__, maxIntTime);
<       return ERROR;
<     }
<   config7 = maxIntTime;
< 
<   if(sumScaleFactor>15)
<     {
<       printf("%s: ERROR: Invalid value for sumScaleFactor (%d).  Must be less than 12.\n",
< 	     __FUNCTION__, sumScaleFactor);
<       return ERROR;
<     }
< 
<   config7 |= ((sumScaleFactor)<<4);
< 
<   faWriteHPSConfig(id, config6, config7);
< 
<   return OK;
< }
< #endif /* HPS */
< 
3976a3388,3472
> void
> fatest1(int id)
> {
>   unsigned int a,b,c,d;
> 
>   if(id==0) id=fadcID[0];
> 
>   if((id<=0) || (id>21) || (FAp[id] == NULL)) 
>   {
>     logMsg("faDready: ERROR : ADC in slot %d is not initialized \n",id,0,0,0,0,0);
>     return(ERROR);
>   }
>   
>   FALOCK;
> 
>   a = vmeRead32(&(FAp[id]->ev_count));
>   b = vmeRead32(&(FAp[id]->blk_count));
>   c = vmeRead32(&(FAp[id]->blk_fifo_count));
>   d = vmeRead32(&(FAp[id]->blk_wrdcnt_fifo));
>   logMsg("fatest1: %d %d %d %d\n",a,b,c,d,5,6);
> 	/*
>   volatile unsigned int ev_count;
>   volatile unsigned int blk_count;
>   volatile unsigned int blk_fifo_count;
>   volatile unsigned int blk_wrdcnt_fifo;
> */
> 
>   FAUNLOCK;
> 
>   return;
> }
> 
> 
> 
> int
> faSetMGTTestMode(int id, unsigned int mode)
> {
>   unsigned int rval=0, wval=0;
> 
>   if(id==0) id=fadcID[0];
> 
>   if((id<=0) || (id>21) || (FAp[id] == NULL)) 
>     {
>       printf("%s: ERROR : ADC in slot %d is not initialized \n",
> 	     __FUNCTION__,id);
>       return(ERROR);
>     }
> 
> #define USEMGTCTRL
> #ifdef USEMGTCTRL
>   FALOCK;
>   if(mode)
>     wval = (1<<1);
>   else
>     wval = 0;
>   /* FIXME: Old way*/
> /*   rval = vmeRead32(&FAp[id]->mgt_ctrl); */
> /*   if(mode) */
> /*     wval = (1<<1); */
> /*   else */
> /*     wval = rval & ~(1<<1); */
> 
>   vmeWrite32(&FAp[id]->mgt_ctrl,wval);
>   FAUNLOCK;
> 
>   printf("%s: mode=%d  rval = 0x%08x    wval = 0x%08x\n",__FUNCTION__,
> 	 mode, rval, wval);
> #else
>   printf("%s: Function disabled\n",__FUNCTION__);
> #endif
> 
>   return(OK);
> }
> 
> 
> 
> #else /* dummy version*/
> 
> void
> fadcLib_dummy()
> {
>   return;
> }
> 
> #endif
